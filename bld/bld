#!/usr/bin/perl

# bld - a simple flexible non-hierarchical program that uses SHA1 signatures
#       to build a single target(executable or library(static or shared)).
#       Complex multi-target projects may be built with the help of the
#       bld.<project> and bld.<project>.rm scripts and uses standard <project>
#       directory structures for the placement of code and Bld files. see
#       bld.README.  do "bld -h" for command help or "perldoc bld" for the
#       full man page

# use modern perl
use 5.018.4;

#
# standard modules
#

use warnings;
use diagnostics;
use autodie;
use English;
use Getopt::Long;
use File::Find;
use Data::Dumper;

# extract_multiple - for parsing the $BGC::BFN DIRS section
# extract_bracketed - used by extract_multiple for finding '{}''s
use Text::Balanced qw(
                         extract_multiple
                         extract_bracketed
                     );

# croak() - used in fatal() to die with better info than die()
# cluck() - used for full stack trace debugging, outputs to stdout
# shortmess() - used for full stack trace debugging, returns stack trace
use Carp qw(
               croak
               cluck
               shortmess
           );

# sha1_hex - the bld program SHA1 generator
use Digest::SHA qw(
                      sha1_hex
                  );

#
# installed modules
#

#use Modern::Perl 2011;

# this module allows the use of experimental perl language features(given, when, ~~) without generating warnings.
# to see exactly where smartmatch features are being used just comment out this line.  bld will run, but with warnings
# everyplace an experimental smartmatch feature is used.
use experimental 'switch';

use lib "./modules";
use BGC;
use BldRoutines qw(
                      init_blddotinfo
                      read_Blddotsig
                      rebuild_target_bool
                      rebuild_exec
                      multiple_sigs
                      buildopt
                      tgtextorfile
                      tgt_signature
                      dirs_pro
                      cvt_dirs_to_array
                      expand_R_specification
                      Bld_section_extract
                      sig_file_update
                      hdr_depend
                      rebuild_src_bool
                      file_sig_calc
                      system_error_msg
                      warning
                      opt_help
                  );

# START: main bld program block
{
    my
    (
        # file related
        @eval,    # contents of the $BGC::BFN file EVAL section
        $dirs,    # contents of the $BGC::BFN file DIRS section before \s+ compression
        @dirs,    # contents of the $BGC::BFN file DIRS section after \s+ compression

        $opt_h,   # -h cmd line help option, do ./bld -h

        $comment_section, # holds comment section in Bld file for printing in $BGC::BIFN file

        # mandatory variable definitions in the EVAL section of $BGC::BFN
            $bld,        # the target to built e.g. executable, libx.a, libx.so
            $bldcmd,     # cmd used in perl system() call to build $bld object - requires '$bld' and '$O'(object files) internally
            $lib_dirs,   # space separated list of directories to search for libraries

            # mandatory option related in the EVAL section of $BGC::BFN
                $opt_s,     # to use system header files in dependency checking("system" or "nosystem")
                $opt_r,     # to inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
                $opt_lib,   # to do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")

        # booleans
        $rebuild_chgsrc, # boolean to indicate a source file has changed
        $rebuild_nosrc,  # boolean to indicate a(any) source file has been deleted
        $rebuild_target, # boolean to indicate the target has:
                         #     1. target is missing
                         #     2. signature of target does not exist in $BGC::SIGFN signature file
                         #     3. signature of target exists in signature file but is changed from actual existing target

        # primary program data structures
            %Sigdata,
                # signature data and build target library dependency data
                #
                # the hash will be two levels(for source file signature, build cmd signature and build target signature data):
                # $Sigdata{<full path or relative path file source>}[<$BGC::SIG_SRC or $BGC::SIG_CMD or $BGC::SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $BGC::SIG_SRC - source signature e.g. signature of 'source.c' or 'header.h' or 'libx.so'
                #         2. $BGC::SIG_CMD - build cmd signature e.g. signature of 'clang -c source.c -lm'
                #         3. $BGC::SIG_TGT - target signature e.g. signature of 'source.o'
                #     c. the values are signatures
                #
                # Example: # signature of source file
                #          $Sigdata{'src/C/main.c'}[$BGC::SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $Sigdata{'src/C/main.c'}[$BGC::SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $Sigdata{'src/C/main.c'}[$BGC::SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $Sigdata{'/usr/include/wchar.h'}[$BGC::SIG_SRC] = '587c23d7ebd0856b9a9a59c8b0c6469bf0c75963';
                #
                #          # signature of relative path header file
                #          $Sigdata{'src/C/head.h'}[$BGC::SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                #          # signature of build target
                #          $Sigdata{'exec-c'}[$BGC::SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for build target library file dependency data):
                # $Sigdata{<build target>}[<$BGC::LIB_DEP>]{<library file name>} = undef
                #     a. the first level hash has a key of the build target file name e.g. exec-c
                #     b. the second level array has an index values of $BGC::LIB_DEP - a library dependency e.g. libm.so
                #     c. the third level hash has a key of the library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $Sigdata{'exec-c'}[$BGC::LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $Sigdata{'exec-c'}[$BGC::LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                # Purpose: holds $BGC::SIGFN file signature data read in at program start for comparison to %SigdataNew program calculated data to
                #          determine what, if anything, to rebuild

            %SigdataNew,
                # signature and dependency information
                #
                # the hash will have two levels(for signature data):
                # $SigdataNew{<full path or relative path file source>}[<$BGC::SIG_SRC or $BGC::SIG_CMD or $BGC::SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $BGC::SIG_SRC - source signature e.g. signature of source.c or header.h or libx.so
                #         2. $BGC::SIG_CMD - build cmd signature e.g. signature of "clang -c source.c -lm"
                #         3. $BGC::SIG_TGT - target signature e.g. signature of source.o
                #     c. the values are signatures
                #
                # Example: # library signature
                #          $SigdataNew{'/lib64/libc.so.6'}[$BGC::SIG_SRC] = '7c135fc5b3aca5ef9064bdbd51608cf1aad6feee';
                #
                #          # build target signature
                #          $SigdataNew{'exec-c'}[$BGC::SIG_SRC] = '95b0de6b76a336aed5bfb1a5fa1d757ccf1eabfc';
                #
                #          # signature of source file
                #          $SigdataNew{'src/C/main.c'}[$BGC::SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $SigdataNew{'src/C/main.c'}[$BGC::SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $SigdataNew{'src/C/main.c'}[$BGC::SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $SigdataNew{'/usr/include/stdc-predef.h'}[$BGC::SIG_SRC] = '51eecd0afe5466d0ea173369fbe0c91657f92d53';
                #
                #          # signature of relative path header file
                #          $SigdataNew{'src/include/head.h'}[$BGC::SIG_SRC] = 'i7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for header file or library file dependency data):
                # $SigdataNew{<full path or relative path file source>}[<$BGC::HDR_DEP or $BGC::LIB_DEP>]{<file name>} = undef
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of two index values:
                #         1. $BGC::HDR_DEP - a header dependency - the source depends on a header e.g. header.h
                #         2. $BGC::LIB_DEP - a library dependency - the $bldcmd for the $bld target depends on a library e.g. libm.so
                #     c. the third level hash has a key of the header or library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $SigdataNew{'exec-c'}[$BGC::LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $SigdataNew{'exec-c'}[$BGC::LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # source file full path header dependency
                #          $SigdataNew{'src/C/main.c'}[$BGC::HDR_DEP]{'/usr/include/_G_config.h'} = undef;
                #
                #          # source file relative path header dependency
                #          $SigdataNew{'src/C/main.c'}[$BGC::HDR_DEP]{'src/C/l.hh'} = undef;
                #
                # Purpose: holds program calculated data - command, source, header, library and target file signature data as well as source file header dependencies and build
                #          cmd library dependencies.  data in this structure is compared with data in the %Sigdata structure to determine what, if anything, to rebuild.  just
                #          before program exit the $BGC::SIG_SRC, $BGC::SIG_CMD and $BGC::SIG_TGT signatures of %SigdataNew are written to $BGC::SIGFN and becomes the %Sigdata for the next run.

            %Objects,
                # object files
                #
                # the hash will be one level:
                # $Objects{<relative path object file>} = undef
                #     a. the keys are the object file relative path name starting from the bld home directory e.g. src/somefile.o
                #     b. the values are undef
                #
                # Example: # the tt.o object file
                #          $Objects{"\'src/C/y/tt.o\'"} = undef;
                #
                #          # the main.o object file
                #          $Objects{"\'src/C/main.o\'"} = undef;
                #
                #          Note: the inclusion of literal single quotes around the source to avoid problems with directories that have embedded spaces
                #
                # Purpose: used in the $bldcmd required variable to build the $bld target

            %SourceSig,
                # source file signatures - signatures for all source files(code or header) or libraries in the build
                #
                # the hash will be two levels:
                # $SourceSig{'<signature>'}{'<full path or relative path file source>'} = undef
                #     a. the first level hash has a key of the source signature e.g. signature of source.c or header.h or libx.so
                #     b. the second level hash has a key of the full or relative path file
                #     c. the values are undef
                #
                # Example: # w.c has same signature as w1.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w.c'} = undef;
                #
                #          # w1.c has same signature as w.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w1.c'} = undef;
                #
                #          # main.c has a unique signature
                #          $SourceSig{'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5'}{'src/C/main.c'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/../include/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/include/head.h'} = undef;
                #
                # Purpose: if %SourceSig has, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
                #          then there is a source or library of the same signature in two different places

            %Targets,
                # target files - relative path(from the bld directory)
                #
                # the hash will be one level:
                # $Targets{'<relative path file target>'} = undef
                #     a. the first level hash has a key of the relative path(from the bld directory) build file target e.g. src/C/main.o(from main.c) or src/C/lex.c(from lex.l)
                #     b. the values are undef
                #
                # Example: # build target of m.c source
                #          $Targets{'src/C/a b/m.o'} = undef;
                #
                #          # build target of main.c source using gcc
                #          $Targets{'src/C/main.o'} = undef;
                #
                #          # build target of main.c source using as
                #          $Targets{'src/C/main.s'} = undef;
                #
                # Purpose: for each source picked up by a DIRS section regex and built by the corresponding cmd a single target file will be produced.
                #          these files in relative path form from the build directory are used as hash keys.  if two identical target file names are created
                #          (both path and file name) they would overwriting one another.  as targets are added to the build, a new hash key that
                #          already exists will fatal().  if a source is not rebuilt then it will not be added to %Targets.  only rebuilt targets are added.
    );

    # initially interrupts just croak(); after the $BGC::BFN file has been processed and the $BGC::SIGFN has been read in, int_sig_handler()
    # will handle them and first write out any partially accumulated new signatures to $BGC::SIGFN and then croak().
    local $SIG{INT} = sub {
                              my (
                                     $signame,
                                 ) = @_;

                                 croak("\nInterrupted with signal $signame");
                          };

    GetOptions
    (
        "h" => \$opt_h,
    ) or fatal("FID 1: GetOptions() failed(use bld -h).");

    fatal("FID 2: Arguments specified - takes only options.") if @ARGV > 0;

    # help msg
    opt_help() if $opt_h;

    {
        # clear $BGC::BIFN, $BGC::BWFN and $BGC::BFFN files

        open my $bifnfh, ">", $BGC::BIFN;
        close $bifnfh;
        open my $bwfnfh, ">", $BGC::BWFN;
        close $bwfnfh;
        open my $bffnfh, ">", $BGC::BFFN;
        close $bffnfh;
    }

    # scan $BGC::BFN file accumulating EVAL lines(in @eval) and DIRS lines(in $dirs) for later processing.
    my ( @tmp ) = Bld_section_extract();
    $comment_section = shift @tmp;
    $dirs = pop @tmp;
    @eval = @tmp;

    if ( @eval == 0 )
    {
        fatal("FID 5: $BGC::BFN EVAL section is empty.");
    }

    {
        # if a $BGC::BGVFN file exists read in as an array and prepend to the @eval array.
        # this allows the $BGC::BGVFN file to serve as a source of global variable defines.

        my @bldrc;

        # slurp in $BGC::BGVFN file to array
        if ( -f "$BGC::BGVFN" and -r "$BGC::BGVFN" )
        {
            open my $bldrcfh, "<", "$BGC::BGVFN";
            @bldrc = <$bldrcfh>;
            close $bldrcfh;
        }

        unshift @eval, @bldrc;
    }

    {
        # eval() the EVAL section code of the $BGC::BFN file.  this must be 'no strict' or
        # interpolation will complain about undefined variables.

        no strict;
        eval "@eval";
        use strict;

        # check for syntax errors($@).  see perldoc.perl.org -> perlvar -> $EVAL_ERROR
        if ( $EVAL_ERROR )
        {
            fatal("FID 6: $BGC::BFN EVAL section: Fatal eval error: $EVAL_ERROR");
        }

        fatal("FID 7: Invalid value for \$opt_s: \'$opt_s\'") if $opt_s ne "system" and $opt_s ne "nosystem";
        fatal("FID 8: Invalid value for \$opt_r: \'$opt_r\'") if $opt_r ne "rebuild" and $opt_r ne "norebuild";
        fatal("FID 9: Invalid value for \$opt_lib: \'$opt_lib\'") if
            $opt_lib ne "nolibcheck" and
            $opt_lib ne "libcheck" and
            $opt_lib ne "warnlibcheck" and
            $opt_lib ne "fatallibcheck";
    }

    if ( not defined $bld or not defined $bldcmd or not defined $lib_dirs )
    {
        fatal("FID 10: One or more of $BGC::BFN file required variable definitions \$bld, \$bldcmd and \$lib_dirs are missing.");
    }

    if ( not defined $opt_s or not defined $opt_r or not defined $opt_lib )
    {
        fatal("FID 11: One or more of $BGC::BFN file required variable definitions \$opt_s and \$opt_r and \$opt_lib are missing.");
    }

    $bld =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{\s+}{ }g; # compress white space to a single space
    $lib_dirs =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $lib_dirs =~ s{\s+}{ }g; # compress white space to a single space

    # if "nosystem" remove library search directories that start with '/'
    if ( $opt_s eq "nosystem" )
    {
        my @tmp = grep { /^[^\/]/ } split /\s+/, $lib_dirs;
        $lib_dirs = join $BGC::SPACE, @tmp;
    }

    # write initial info to the bld.info file
    init_blddotinfo( $bld, $bldcmd, $lib_dirs, $opt_s, $opt_r, $opt_lib, $comment_section );

    # process $BGC::BFN file DIRS section
    @dirs = dirs_pro( $dirs, $opt_s );

    # scan EVAL and DIRS sections for variables.  if variables in EVAL but not in DIRS do warning().
    # if variables in DIRS but not in EVAL, do warning() and fatal().
    variable_match( \@eval, \@dirs );

    # read $BGC::SIGFN file data into %Sigdata
    read_Blddotsig( $bld, \%Sigdata );

    # enable ^C interruption
    local $SIG{INT} = \&int_sig_handler;

    # 
    # Usage      : ^C
    #            : kill INT => $PID;
    #
    # Purpose    : interrupt handler, not called directly, but by the program receiving at INT signal.
    #            : this may happen in two ways - a. a ^C is typed at the keyboard during program execution and
    #            : b. during a call to the fatal() routine.  fatal() prints it's calling msg to the $BGC::BFFN file
    #            : and then signals an INT to the program.
    #
    # Parameters : called with the SIG name of the interrupt
    #
    # Returns    : None
    #
    # Globals    : %Sigdata
    #            : %SigdataNew
    #
    # Throws     : croak()'s
    #
    # Notes      : None
    #
    # See Also   : None
    #
    sub int_sig_handler
    {
        #requires global variables:
        my (
               $signame,
           ) = @_;

        %SigdataNew = ( %SigdataNew, %Sigdata );

        sig_file_update( $bld, \%SigdataNew );

        croak("\nInterrupted with signal $signame");
    }


    #
    # CHECK COMPILATION UNITS
    #

    # boolean to indicate that any source file was rebuilt and thus $bld will need rebuilding
    $rebuild_chgsrc = "false";

    # for each directory line in $BGC::BFN, check sources and if needed rebuild with $cmd
    # for that directory.  a source file will be rebuilt if a $BGC::SIGFN file signature entry
    # does not exist for this source file, indicating a new source file, or the source
    # file signature has changed.

    foreach my $line ( @dirs )
    {
        given ( $line )
        {
            when ( m{$BGC::RGX_CMD_BLOCK} )
            {
                # DIRS section cmd block
                my $cmd = $line;

                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                my $cmd_var_sub = var_sub( $cmd );

                if ( $cmd_var_sub ne $BGC::EMPTY )
                {
                    my ( $status, $error_msg );

                    $cmd_var_sub =~ s{!!!}{\n}g;

                    # execute $cmd's
                    $status = system "$cmd_var_sub";

                    if ( $status != 0 )
                    {
                        $error_msg = system_error_msg( $CHILD_ERROR, $ERRNO );

                        fatal("FID 17: Error msg: $error_msg\nCmd: \"$cmd_var_sub\"\nFail status: $status");
                    }
                }

                print "{$cmd_var_sub}\n";
                next;
            }
            when ( m{$BGC::RGX_VALID_DIRS_LINE} )
            {
                # DIRS section three field specification line - '[R] dir:regex:{cmds}'

                # split dir lines on ":" and remove $regex_srcs enclosing '{' and '}', and $cmd enclosing '{' and '}'
                my ($dir, $regex_srcs, $cmd) = split $BGC::COLON, $line;

                # add double quotes around the source file $s in order to handle spaces in the file name
                $cmd =~ s{\$s}{"\$s"}g;

                $regex_srcs =~ s{^\{|\}$}{}g; # remove $regex_srcs regex delimiters
                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                opendir my ( $dirfh ), $dir;

                # a. read $dir directory b. select only ordinary files that match $regex_srcs c. map files to relative path name
                my @Sources = map { "$dir/$_" } grep { $_ =~ m{$regex_srcs} and -f "$dir/$_" } readdir $dirfh;
                closedir $dirfh;

                foreach my $s ( @Sources )
                {
                    my ( $truefalse );

                    $truefalse = src_pro( $s, $cmd, $bld, $opt_s, $opt_r, \%Sigdata, \%BGC::Depend, \%SigdataNew, \%SourceSig, \%Objects, \%Targets );

                    # if any $s needs rebuilding set $rebuild_chgsrc to "true"
                    if ( $truefalse eq "true" )
                    {
                        $rebuild_chgsrc = "true";
                    }
                } # END: foreach my $s (@Sources){}
            }
            default
            {
                fatal("FID 18: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");
            }
        }
    } # END: foreach my $line ( @dirs ){}

    if ( not %Objects )
    {
        fatal("FID 19: No source file matched in any DIRS section line regular expression.");
    }


    #
    # CHECK TARGET AND REBUILD IF NECESSARY
    #

    # boolean indicating to rebuild target if any of three conditions is true:
    #     1. target is missing
    #     2. signature of target does not exist in $BGC::SIGFN signature file
    #     3. signature of target exists in signature file but is changed from actual existing target
    $rebuild_target = rebuild_target_bool( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Sigdata, \%SigdataNew );

    # if a(any) source has been deleted($s exists in %Sigdata and does not exist in %SigdataNew) then force rebuild
    $rebuild_nosrc = "false";
    foreach my $s ( keys %Sigdata )
    {
        if ( not $s ~~ %SigdataNew )
        {
            $rebuild_nosrc = "true";
        }
    }

    # rebuild if:
    #     1. a source file of executable has changed($rebuild_chgsrc)
    #     2. or a source file has been deleted($rebuild_nosrc)
    #     3. or the target is has any of the three conditions listed above($rebuild_target)
    if ( $rebuild_chgsrc eq "true" or $rebuild_nosrc eq "true" or $rebuild_target eq "true" )
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that would be rebuilt, but do not rebuild
            print "---WILL--- be rebuilt: $bld\n";
        }
        else
        {
            rebuild_exec( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Objects, \%SigdataNew );
        }
    }
    else
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that will not be rebuilt
            print "$bld will NOT be rebuilt.\n";
        }
        else
        {
            print "$bld is up to date.\n";
        }
    }

    # DEBUG
    # if debugging, for dumping the primary program data structures
=for
    print "DEBUG:\n";
    print Data::Dumper->new([\%Depend],[qw(\%Depend)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Sigdata],[qw(\%Sigdata)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SigdataNew],[qw(\%SigdataNew)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Objects],[qw(\%Objects)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SourceSig],[qw(\%SourceSig)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Targets],[qw(\%Targets)])->Indent(3)->Quotekeys(0)->Dump;
    print "ENDDEBUG:\n";
=cut

    # if %SourceSig, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
    # then there is a source or library of the same signature in two different places
    multiple_sigs( \%SourceSig );

    # if $opt_r option is "norebuild" do not rebuild - do not touch $BGC::SIGFN file
    if ( $opt_r eq "norebuild" ) { exit 0; }

    # ignore interrupts while $BGC::SIGFN is being written
    local $SIG{INT} = 'IGNORE';

    # writes %SigdataNew signature data to $BGC::SIGFN and header/code file inventory to $BGC::BIFN
    sig_file_update( $bld, \%SigdataNew );

    exit 0;
}
# END: main bld program block


#
# SUBROUTINES SECTION - Global data dependent(only var_sub())
#
#     Note: The global data is all of the variables imported from the EVAL section of the $BGC::BFN file by the eval "" of that section
#


# 
# Usage      : $cmd_var_sub = var_sub( $cmd );
#            :     - note: called in scalar context
#            : %dirs_vars_tmp = var_sub( $cmd, '$s' );
#            :     - note: called in list context
#            : %eval_vars = var_sub( $eval_vars, '$bld', '$bldcmd', '$lib_dirs', '$O', '$opt_s', '$opt_r', '$opt_lib' );
#            :     - note: called in list context
#
# Purpose    : depending on the calling context do:
#            :     1. scalar context - simple variable($name) substitution and return the substituted string.
#            :     2. list context - create a hash of string,
#            :        for $a = 1 - key = 'simple variable name($a -> 'a')'/value = 'simple variable value(1)',
#            :        entries and return the hash.
#            : exclude from processing the list of variable entries after the $cmd input string.
#            : the return depends on calling context(see wantarray()).
#
# Parameters : $cmd     - command string
#            :            Note: $cmd may have embedded newlines.  this is OK as m{\$(\w+)}g should match newlines.
#            :
#            : @exclude - list of variables to exclude from substitution - applies to both $cmd and %h returns.
#            :            these variables may be specified either with or without the leading '$' sign. e.g. '$bld' or 'bld'
#
# Returns    :     1. if wantarray is false:
#            :            do variable substitution on $cmd, excepting variable names
#            :            passed in the @exclude array, and return it
#            :     2. if wantarray is true:
#            :            extract variable names from $cmd and build a hash with variable names
#            :            as keys and values as the values of those variables - return that hash
#
# Globals    : All of the variables imported from the EVAL section by the eval "" of that section
#
# Throws     : None
#
# Notes      : 1. the exclude list may have variables listed without the scalar variable prefix $ sign e.g. 'bld'.  however,
#            :    '$bld' seems better because it reminds the user that the exclude list is a list of variables.
#            : 2. the @exclude arguments must not be interpolated - thus they should be of the form '$string' with single quotes
#            : 3. ignore entirely any %hash variables($hash{a}) or @array variables($array[0]) -
#            :    these may be used freely in the EVAL section
#
# See Also   : perldoc -f wantarray
#
sub var_sub
{
    my (
           $cmd,
           @exclude,
       ) = @_;

    # hash with variable/variable value
    my ( %h );

    # for return type
    my ( $wantarray );


    $wantarray = wantarray();

    foreach my $exclude ( @exclude )
    {
        $exclude =~ s{^\$}{}; # strip leading '$' sign
    }

    # find all(except from @exclude) simple perl variables($name) and, depending on the calling context,
    # either substitute their values or build a hash with variable/variable value entries.  ignore
    # entirely any %hash variables($hash{a}) or @array variables($array[0])
    while ( $cmd =~ m{ \$(\w+)(?:\s|=) }gx )
    {
        my $varmatch = $1;

        # if $varmatch is in @exclude skip it
        last if $varmatch ~~ @exclude;

        no strict;
        if ( $wantarray )
        {
            $h{"\$$varmatch"} = ${$varmatch};
        }
        else
        {
            $cmd =~ s{\$$varmatch}{${$varmatch}};
        }
        use strict;
    }

    return $wantarray ? %h : $cmd;
}


#
# SUBROUTINES SECTION - Global data independent
#
#     Note: All subroutine data comes from their arguments(except globally defined constants).
#           They return all data thru their return lists.  No global data is used.  Some routines
#           write to files e.g. bld.warn, bld.info.  Some subroutines read files in order to
#           calculate signatures.
#


# 
# Usage      : variable_match( \@eval, \@dirs );
#
# Purpose    : scan EVAL section code for scalar variables and make %eval_vars hash.  scan DIRS section cmd fields and make %dirs_vars hash.
#            : compare the two hashes.  if %eval_vars variables are not in %dirs_vars, issue warnings.  if %dirs_vars variables are not in
#            : %eval_vars then issue warnings and fatal errors.
#
# Parameters : $eval_ref - reference to array of EVAL section lines
#              $dirs_ref - reference to array of DIRS section lines
#
# Returns    : None
#
# Globals    : None
#
# Throws     : None
#
# Notes      : None
#
# See Also   : None
#
sub variable_match
{
    my (
           $eval_ref,
           $dirs_ref,
       ) = @_;

    my ( %eval_vars, %dirs_vars );


    # scan EVAL section and make %eval_vars hash
    foreach my $line ( @{$eval_ref} )
    {
        chomp $line;

        # create hash of all variable name/variable value pairs in $eval_vars with all mandatory defines excluded
        my %eval_vars_tmp = var_sub( $line, '$bld', '$bldcmd', '$lib_dirs', '$O', '$opt_s', '$opt_r', '$opt_lib' );
        %eval_vars = ( %eval_vars, %eval_vars_tmp );

        if ( "\$s" ~~ %eval_vars )
        {
            fatal("FID 55: The scalar variable \$s may not be specified in the EVAL section, as this is used in the DIRS".
                  " section command field to signify matched source files.");
        }
    }

    # scan DIRS section and substitute scalar variables and make %dirs_vars hash
    foreach my $line ( @{$dirs_ref} )
    {
        chomp $line;

        given ( $line )
        {
            when ( m{$BGC::RGX_CMD_BLOCK} )
            {
                # DIRS section cmd block
                my $cmd = $line;

                my %dirs_vars_tmp = var_sub( $cmd );
                %dirs_vars = ( %dirs_vars, %dirs_vars_tmp );
            }
            when ( m{$BGC::RGX_VALID_DIRS_LINE} )
            {
                # DIRS section three field specification line
                my ($dir, $regex_srcs, $cmd);

                ($dir, $regex_srcs, $cmd) = split $BGC::COLON, $line;

                my %dirs_vars_tmp = var_sub( $cmd, '$s' );
                %dirs_vars = ( %dirs_vars, %dirs_vars_tmp );
            }
            default
            {
                fatal("FID 56: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");
            }
        }
    }

    {
        # if %eval_vars variables not in %dirs_vars then issue warnings and if %dirs_vars variables not in
        # %eval_vars then issue warnings and fatal errors

        my (@evalextra, @dirsextra);

        # find all variables in EVAL section that are not in DIRS cmds excluding mandatory defines
        foreach my $key ( keys %eval_vars )
        {
            if ( not $key ~~ %dirs_vars )
            {
                push @evalextra, $key;
            }
        }

        # find all variables in DIRS cmds that are not in EVAL section(excluding $s)
        foreach my $key ( keys %dirs_vars )
        {
            if ( not $key ~~ %eval_vars )
            {
                push @dirsextra, $key;
            }
        }

        if ( not @evalextra == 0 )
        {
            warning("WID 16: EVAL defined variable(s) not used in DIRS cmds: @evalextra");
        }

        if ( not @dirsextra == 0 )
        {
            warning("WID 17: DIRS cmd variable(s) not defined in EVAL section: @dirsextra");
            fatal("FID 57: Extra unused variable(s) in DIRS section - see $BGC::BWFN.");
        }
    }

    {
        open my $bifnfh, ">>", $BGC::BIFN;

        # print expansion of eval{} section defined variables that appear in $cmd's
        print {$bifnfh} "\n####################################################################################################\n";
        print {$bifnfh} "EVAL section expansion of defined variables used in DIRS section cmd fields:\n\n";
        foreach my $key ( sort keys %eval_vars )
        {
            print {$bifnfh} "$key = $eval_vars{$key}\n";
        }
        print {$bifnfh} "\n";
        close $bifnfh;
    }

    return;
}


# 
# Usage      : my ( @tmp ) = accum_blddotinfo_output( $opt_s, @dirs );
#
# Purpose    : accumulate lines to be printed to the $BGC::BIFN file:
#            :     a. DIRS section specification lines with a line count number
#            :     b. variable interpolated(except for \$s) specification line cmd field
#            :     c. matching compilation unit source file(s)
#            :     d. source file header dependencies
#            :     e. check for the following error conditions:
#            :        1. either a directory or a source file is not readable
#            :        2. multiple build entries in $BGC::BFN file DIRS section lines matching same source file
#            :        3. Bad char(not [\/A-Za-z0-9-_.]) in directory specification "$dir"
#            :        4. Invalid regular expression - "$regex_srcs"
#            :        5. No '$s' variable specified in DIRS line command field
#            :        6. No sources matched in $BGC::BFN DIRS section line $line
#            :        7. Source file specified in more than one DIRS line specification
#
# Parameters : $opt_s - to use system header files in dependency checking("system" or "nosystem")
#            : @dirs  - @dirs will have one cmd block({}) or one '[R] dir:regex:{cmds}' specification per array element
#
# Returns    : $fatal_not_readable     - either a directory or a source file is not readable
#            : $fatal_multiple_sources - multiple build entries in $BGC::BFN file DIRS section lines matching same source file
#            : @bldcmds                - output for Bld.info
#
# Globals    : None
#
# Throws     : None
#
# Notes      : None
#
# See Also   : None
#
sub accum_blddotinfo_output
{
    my (
           $opt_s,
           @dirs,
       ) = @_;

    # output for Bld.info
    my ( @bldcmds );

    # either a directory or a source file is not readable
    my ( $fatal_not_readable ) = "false";

    # multiple build entries in $BGC::BFN file DIRS section lines matching same source file
    my ( $fatal_multiple_sources ) = "false";

    # hash with keys of the source file names(basename only) for detection of multiple source
    # files of the same name in different DIRS line specifications
    my ( %s );

    # integer count of the DIRS section specification lines
    my ( $count ) = 0;


    foreach my $line ( @dirs )
    {
	$count++;

	push @bldcmds, sprintf "----------\n%4d  %s\n", $count, $line;

	given ( $line )
	{
	    when ( m{$BGC::RGX_CMD_BLOCK} )
	    {
		# DIRS section cmd block
		my $cmd = $line;

		# variable interpolate cmd block
		my $cmd_var_sub = var_sub( $cmd );

		push @bldcmds, "      $cmd_var_sub\n";
		push @bldcmds, "\n";
	    }
	    when ( m{$BGC::RGX_VALID_DIRS_LINE} )
	    {
		# DIRS section three field specification line
		my ($dir, $regex_srcs, $cmd);

		chomp $line;
		($dir, $regex_srcs, $cmd) = split $BGC::COLON, $line;

		# check $dir for existence and readability
		if ( not -e "$dir" or not -r "$dir" )
		{
		    {
			open my $bffnfh, ">>", $BGC::BFFN;
			print {$bffnfh} "Directory \"$dir\" specification in $BGC::BFN file DIRS line $count cannot be read.\n";
			close $bffnfh;
		    }

		    $fatal_not_readable = "true";
		    next;
		}

		# check $dir for invalid chars
		if ( $dir !~ m{^$BGC::RGX_VALID_PATH_CHARS+$} )
		{
		    fatal("FID 48: Bad(really weird) char(not $BGC::RGX_VALID_PATH_CHARS) in directory specification: $dir");
		}

		# check $regex_srcs for valid regular expression
		eval { $BGC::EMPTY =~ m{$regex_srcs} };
		if ( $EVAL_ERROR )
		{
		    fatal("FID 49: Invalid regular expression - \"$regex_srcs\".");
		}

		# variable interpolate $cmd - exclude $s interpolation
		my $cmd_var_sub = var_sub( $cmd, '$s' );

		# scan $cmd_var_sub for '$s' and fatal() if none found and warning() if more than one found
		{
		    my ( $n );

		    while ( $cmd_var_sub =~ m{ \$s }gx )
		    {
			$n++;
		    }

		    if ( $n == 0 )
		    {
			fatal("FID 50: No '\$s' variable specified in DIRS line command field: $cmd_var_sub");
		    }

		    if ( $n > 1 )
		    {
			warning("WID 11: Multiple($n) '\$s' variables specified in DIRS line command field: $cmd_var_sub");
		    }
		}

		push @bldcmds, "      $cmd_var_sub\n";

		# accumulate source files that match this directory search criteria
		opendir my ( $dirfh ), $dir;
		my @Sources = map { "$dir/$_" } grep { $_ =~ m{$regex_srcs} and -f "$dir/$_" } readdir $dirfh;
		closedir $dirfh;

		if ( @Sources == 0 )
		{
		    warning("WID 12: No sources matched in $BGC::BFN DIRS section line $line");
		}

		{
		    # dummy variable
		    my ( $vol, $path );

		    # source file name(with extension)
		    my $basename;


		    # loop over all source files matched by this ($dir, $regex_srcs, $cmd) DIRS line specification $regex_srcs
		    foreach my $s ( @Sources )
		    {
			# check $s for existence and readability
			if ( not -e "$s" or not -r "$s" )
			{
			    my $string = sprintf "Source file %s does not exist or is not readable.\n   %4d  %s", $s, $count, $line;
			    warning("WID 13: $string");

			    $fatal_not_readable = "true";
			    next;
			}

			# extract the basename
			( $vol, $path, $basename ) = File::Spec->splitpath( $s );

			# if $basename already exists in %s then the same source file has been specified in more than one DIRS line specification - warn and fatal
			if ( $basename ~~ %s )
			{
			    # error msg will print the line count and the line for both DIRS line specifications
			    my $string = sprintf "Source file %s specified in more than one DIRS line specification:\n   %s\n   %4d  %s", $s, $s{"$basename"}, $count, $line;
			    warning("WID 14: $string");

			    $fatal_multiple_sources = "true";
			}
			else
			{
			    # save $basename in %s with the line count and the line
			    $s{"$basename"} = sprintf "%4d  %s", $count, $line;
			}

			push @bldcmds, "          $s\n";

			my ( @hdeps, $srcext );

			# capture file name extension
			if ( $s =~ m{.*[.]$BGC::RGX_FILE_EXT} )
			{
			    $srcext = $1;
			}
			else
			{
			    fatal("FID 51: Valid file extension not found in $s");
			}

			given ( $srcext )
			{
			    when (
				     $srcext ~~ $BGC::Depend{'hdr'}{'c'} or
				     $srcext ~~ $BGC::Depend{'hdr'}{'S'} or
				     $srcext ~~ $BGC::Depend{'hdr'}{'E'} or
				     $srcext ~~ $BGC::Depend{'hdr'}{'n'}
				 )
			    {
				# $s is a hdr processible file
				# find all header file dependencies of source file
				@hdeps = hdr_depend( $cmd_var_sub, $s, "" );
			    }
			    when ( $srcext ~~ $BGC::Depend{'nothdr'}{'c'} )
			    {
				; # noop for recognizable not header file processible $srcext
			    }
			    default
			    {
				fatal("FID 52: $BGC::BFN DIRS section source file $s has no recognizable extension(see %Depend)");
			    }
			}

			# accumulate header file in @bldcmds appropriate for $opt_s
			foreach my $h ( @hdeps )
			{
			    # 
			    if ( $opt_s eq "nosystem" and $h =~ m{ ^\/.*[.]$BGC::RGX_HDR_EXT$ }x ) {next;}

			    push @bldcmds, "              $h\n";
			} # END: foreach my $line ( @hdeps ){}
		    } # END: foreach my $s ( @Sources ){}
		}
		push @bldcmds, "\n";
	    }
	    default
	    {
		fatal("FID 53: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");
	    }
	} # END: given ( $line ){}
    } # END: foreach my $line ( @dirs ){}

    return ( $fatal_not_readable, $fatal_multiple_sources, @bldcmds );
}


# 
# Usage      : $truefalse = src_pro( $s, $cmd, $bld, $opt_s, $opt_r, \%Sigdata, \%Depend, \%SigdataNew, \%SourceSig, \%Objects, \%Targets );
#
# Purpose    : source file processing
#
# Parameters : $s           - code source file
#            : $cmd         - rebuild cmds
#            : $bld         - the target to built e.g. executable or libx.a or libx.so
#            : $opt_s       - to use system header files in dependency checking("system" or "nosystem")
#            : $opt_r       - to inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
#            : \%Sigdata    - hash holding $BGC::SIGFN file signature data
#            : \%Depend     - source file extension dependencies e.g. c -> o and m -> o
#            : \%SigdataNew - hash holding bld calculated command, source, header, library and target file signature data
#            : \%SourceSig  - source signatures - see above
#            : \%Objects    - all object files for the build - see above
#            : \%Targets    - all target files for the build - see above
#
# Returns    : boolean("true"/"false") to indicate that any source file was rebuilt and thus $bld will need rebuilding
#
# Globals    : None
#
# Throws     : None
#
# Notes      : None
#
# See Also   : None
#
sub src_pro
{
    my (
           $s,
           $cmd,
           $bld,
           $opt_s,
           $opt_r,
           $Sigdata_ref,
           $Depend_ref,
           $SigdataNew_ref,
           $SourceSig_ref,
           $Objects_ref,
           $Targets_ref,
       ) = @_;

    fatal("FID 26: src_pro(): wrong number of args") if @_ != 11;

    my ( $cmd_var_sub );
    my ( $hdr, $srcext, $tgtextorfile );
    my ( $buildopt );
    my ( $srcvol, $srcpath, $srcfile );
    my ( %SigdataNew_tmp );


    ( $srcvol, $srcpath, $srcfile ) = File::Spec->splitpath( $s );

    # set $srcext for later use
    if ( $srcfile =~ m{.*[.]$BGC::RGX_FILE_EXT} )
    {
        $srcext = $1;
    }
    else
    {
        fatal("FID 27: Valid file extension not found in $s");
    }

    # set $hdr to indicate the $s source file is or is not header processible
    given ( $srcext )
    {
        when (
                 $srcext ~~ $BGC::Depend{'hdr'}{'c'} or
                 $srcext ~~ $BGC::Depend{'hdr'}{'S'} or
                 $srcext ~~ $BGC::Depend{'hdr'}{'E'} or
                 $srcext ~~ $BGC::Depend{'hdr'}{'n'}
             )
        {
            # $s is a hdr processible file
            $hdr = "hdr";
        }
        when ( $srcext ~~ $BGC::Depend{'nothdr'}{'c'} )
        {
            # $s is a not hdr processible file
            $hdr = "nothdr";
        }
        default
        {
            fatal("FID 28: $BGC::BFN DIRS section source file $s has no recognizable extension(see %Depend)");
        }
    }

    # calculate signature of source file and save in %SigdataNew
    $SigdataNew_tmp{$s}[$BGC::SIG_SRC] = file_sig_calc( $s );

    # find $VARIABLEs in $cmd and substitute EVAL section values for these variables.
    # NOTE: do 'perldoc -q "How can I expand variables in text strings"' to see a discussion
    #       of how this(s{}{}gee) works and possible alternatives.

    $cmd_var_sub = $cmd;
    no strict;
    $cmd_var_sub =~ s{(\$\w+)}{$1}gee;
    use strict;

    # for the signature calculation only compress out '!!!'s - this makes the signature insensitive to
    # bracketing changes or added/deleted newlines.  when the cmd is executed and printed, however, the
    # '!!!'s will be translated back to newlines.
    my $cmd_sig = $cmd_var_sub;
    $cmd_sig =~ s{!!!}{}g;

    # calculate signature of variable substituted source $cmd_sig
    $SigdataNew_tmp{$s}[$BGC::SIG_CMD] = sha1_hex( $cmd_sig );

    # populate source signature hash %SourceSig - see definition above
    ${$SourceSig_ref}{"$SigdataNew_tmp{$s}[$BGC::SIG_SRC]"}{$s} = undef;

    # return which cmd line option(-c or -S or -E or (none of these)) is in effect
    $buildopt = buildopt( $s, $cmd_var_sub, $hdr, $srcext, $Depend_ref, $Objects_ref );

    # return the $s target extension or file name
    $tgtextorfile = tgtextorfile( $s, $hdr, $srcext, $srcpath, $srcfile, $buildopt, \%SigdataNew_tmp, $Depend_ref );

    if ( $hdr eq "hdr" )
    {
        # calculate signatures of header files for this source code file($s).
        # For each header file $h(in @hdeps):
        #     a. add $SigdataNew{$h}[SIG_SRC] = sha1_hex( $h );
        #     b. add $SigdataNew{$s}[HDR_DEP]{$h} = undef;

        # for interpolated $cmd_var_sub of this source find the header file dependencies.
        # do not require header files to be searched for in the path(-MG).
        my @hdeps = hdr_depend( $cmd_var_sub, $s, "-MG" );

        foreach my $h ( @hdeps )
        {
            if ( $opt_s eq "nosystem" and $h =~ m{ ^\/.*[.]$BGC::RGX_HDR_EXT$ }x ) {next;}

            # calculate signature of header file
            if ( not $h ~~ %SigdataNew_tmp )
            {
                $SigdataNew_tmp{$h}[$BGC::SIG_SRC] = file_sig_calc( $h );
            }

            # add header files to %SigdataNew header dependencies
            $SigdataNew_tmp{$s}[$BGC::HDR_DEP]{$h} = undef;
        } # END: foreach my $line ( @hdeps ){}
    }

    # DEBUG
=for
    print "DEBUG:\n".
          "\$s = $s\n".
          "\$buildopt = $buildopt\n".
          "\$srcext = $srcext\n".
          "\$tgtextorfile = $tgtextorfile\n".
          "\$srcvol = $srcvol\n".
          "\$srcpath = $srcpath\n".
          "\$srcfile = $srcfile\n".
          "ENDDEBUG\n";
=cut

    # see if $s should be rebuilt by testing %Sigdata against %SigdataNew
    if ( rebuild_src_bool( $s, $tgtextorfile, $Sigdata_ref, \%SigdataNew_tmp ) eq "true" )
    {
        # print source file names that will be rebuilt, but do not rebuild
        if ( $opt_r eq "norebuild" )
        {
            print "---WILL--- be rebuilt: $s\n";
        }
        else
        {
            my ( $status, $error_msg );
            my ( %before, %after, @difference );
            my ( $dirfh );

            # create hash of files in the bld directory before "$cmd_var_sub" execution
            opendir $dirfh, ".";
            while ( readdir $dirfh )
            {
                $_ =~ s{\n}{};
                $before{"$_"} = undef;
            }
            closedir $dirfh;

            $cmd_var_sub =~ s{!!!}{\n}g;

            # execute $cmd's
            $status = system "$cmd_var_sub";

            if ( $status != 0 )
            {
                $error_msg = system_error_msg( $CHILD_ERROR, $ERRNO );

                fatal("FID 36: Error msg: $error_msg\nCmd: \"$cmd_var_sub\"\nFail status: $status");
            }

            print "$cmd_var_sub\n";

            # create hash of files in the bld directory after "$cmd_var_sub" execution
            opendir $dirfh, ".";
            while ( readdir $dirfh )
            {
                $_ =~ s{\n}{};
                $after{"$_"} = undef;
            }
            closedir $dirfh;

            # create array of new files created by "$cmd_var_sub" execution
            foreach my $f ( keys %after )
            {
                if ( not exists $before{$f} )
                {
                    push @difference, $f;
                }
            }

            if ( @difference == 0 )
            {
                fatal("FID 37: No new target files created by command:\nCmd: \"$cmd_var_sub\"");
            }

            # 
            tgt_signature( $s, $hdr, $srcext, $srcpath, $srcfile, $buildopt, \%SigdataNew_tmp, $Depend_ref, \@difference, $Targets_ref);

            # move all new files in the bld directory created by "$cmd_var_sub" execution
            # to the directory of the $s source
            while ( @difference )
            {
                my $newfile = shift @difference;

                $status = system "mv", "$newfile", "$srcpath";

                if ( $status != 0 )
                {
                    $error_msg = system_error_msg( $CHILD_ERROR, $ERRNO );

                    fatal("FID 41: Error msg: $error_msg\n\"mv $newfile $srcpath\" fail status: $status");
                }
            }
        }

        # since the $cmd_var_sub has built successfully add the tmp data stored in the local
        # hash %SigdataNew_tmp to the passed in \%SigdataNew hash references
        $SigdataNew_ref->{$s}[$BGC::SIG_SRC] = $SigdataNew_tmp{$s}[$BGC::SIG_SRC];
        $SigdataNew_ref->{$s}[$BGC::SIG_CMD] = $SigdataNew_tmp{$s}[$BGC::SIG_CMD];
        $SigdataNew_ref->{$s}[$BGC::SIG_TGT] = $SigdataNew_tmp{$s}[$BGC::SIG_TGT];

        # populate source signature hash %SourceSig - see definition above
        ${$SourceSig_ref}{"$SigdataNew_tmp{$s}[$BGC::SIG_SRC]"}{$s} = undef;

        if ( $hdr eq "hdr" )
        {
            foreach my $h ( keys %SigdataNew_tmp )
            {
                if ( $h ne $s )
                {
                    $SigdataNew_ref->{$h}[$BGC::SIG_SRC] = $SigdataNew_tmp{$h}[$BGC::SIG_SRC];
                    $SigdataNew_ref->{$s}[$BGC::HDR_DEP]{$h} = $SigdataNew_tmp{$s}[$BGC::HDR_DEP]{$h};

                    # populate source signature hash %SourceSig - see definition above
                    ${$SourceSig_ref}{"$SigdataNew_tmp{$h}[$BGC::SIG_SRC]"}{$h} = undef;
                }
            }
        }

        return "true";
    }
    else
    {
        # print source file names that will not be rebuilt
        if ( $opt_r eq "norebuild" )
        {
            print "$s will NOT be rebuilt.\n";
        }
        else
        {
            print "$s is up to date.\n";
        }

        # since the $cmd_var_sub has built successfully add the tmp data stored in the local
        # hash %SigdataNew_tmp to the passed in \%SigdataNew hash references
        $SigdataNew_ref->{$s}[$BGC::SIG_SRC] = $SigdataNew_tmp{$s}[$BGC::SIG_SRC];
        $SigdataNew_ref->{$s}[$BGC::SIG_CMD] = $SigdataNew_tmp{$s}[$BGC::SIG_CMD];
        $SigdataNew_ref->{$s}[$BGC::SIG_TGT] = $SigdataNew_tmp{$s}[$BGC::SIG_TGT];

        # populate source signature hash %SourceSig - see definition above
        ${$SourceSig_ref}{"$SigdataNew_tmp{$s}[$BGC::SIG_SRC]"}{$s} = undef;

        if ( $hdr eq "hdr" )
        {
            foreach my $h ( keys %SigdataNew_tmp )
            {
                if ( $h ne $s )
                {
                    # move header file signatures and source header file dependencies to \%SigdataNew
                    $SigdataNew_ref->{$h}[$BGC::SIG_SRC] = $SigdataNew_tmp{$h}[$BGC::SIG_SRC];
                    $SigdataNew_ref->{$s}[$BGC::HDR_DEP]{$h} = $SigdataNew_tmp{$s}[$BGC::HDR_DEP]{$h};

                    # populate source signature hash %SourceSig - see definition above
                    ${$SourceSig_ref}{"$SigdataNew_tmp{$h}[$BGC::SIG_SRC]"}{$h} = undef;
                }
            }
        }

        return "false";
    }
}


# 
# Usage      : fatal("fatal msg");
#
# Purpose    : accept msg as arg and append it to $BFFN file, then self 'kill INT' to
#            : call the anonymous interrupt($SIG{INT}) handler routine to croak().
#
# Parameters : $msg - a single scalar msg
#
# Returns    : Does not return
#
# Globals    : None
#
# Throws     : None
#
# Notes      : None
#
# See Also   : warning()
#
sub fatal
{
    my (
           $msg,
       ) = @_;

    my ( $package, $filename, $line ) = caller;

    open my $bffnfh, ">>", $BGC::BFFN;
    printf {$bffnfh} "line: %4d - %s\n\n", $line, $msg;
    close $bffnfh;

    kill INT => $PID;

    return;
}

1;

__END__

=head1 NAME

 bld

=head1 VERSION

 bld version 1.0.0

=head1 USAGE

 usage: bld [-h]
     -h          - this message.(exit)

=head1 ARGUMENTS

 None

=head1 OPTIONS

bld [-h]

-h
        help message(exit)

=head1 ENVIRONMENT VARIABLES

 None

=head1 RC CONFIGURATION FILES

 None

=head1 DEPENDENCIES

 Required for execution:
    experimental.pm(3pm) - for smartmatch and switch features
    cpp(1) - gnu cpp cmd is required for dependency determination
    ldd(1) - used for library dependency determination

 Required for test:
    gcc(1)/g++(1) (http://gcc.gnu.org/)
    clang(1) (http://llvm.org/)

=head1 FEATURES AND ADVANTAGES

 1. Everything is done with SHA1 signatures.  No dates are used anywhere.  Signatures are a property of the
    file and not meta data from the system used for the build.  Any time issues, whether related to local
    clocks, networked host clocks or files touched by command activities are eliminated.  Modern signature
    algorithms are strongly randomized even for small file changes - for the 160 bit SHA1 hash collisions are
    unlikely in the extreme.  The Digest::SHA module is fast.  The expense of signature calculation times 
    is small relative to the expense of programmer time.  An investigation of some other make alternatives
    e.g. scons, cook - will disclose that they too are using signatures - maybe for exactly for the same reasons.
 2. bld is REALLY simple to use.  There are no arguments, no options(except -h), no environment variables and
    no rc files.  The entire bld is controlled from the Bld(and Bld.gv file) file.  Only a minimal knowledge
    of perl is needed - variable definitions and simple regular expressions.
 3. Automatic dependency checking - GNU cpp is used to find the header file dependencies.  Optionally, header
    file checking may be done for user header files only or for simultaneously both system header and user
    header files.  All header file dependency information associated with each source is saved to the
    bld.info file.
 4. There are no built in dependency rules.  The Bld file DIRS section specifications give what is to be
    built from what and the Bld file EVAL section gives how to assemble all the components for the target.
 5. bld is not hierarchical.  A single Bld file controls the construction of a single target(a target is an
    executable or library(static or shared)).  Complex multi-target projects use one Bld.gv(global values)
    file and many Bld files - one to a target.  The source directory structure goes under bld.<project>/<version>
    and each target Bld file(Bld.<project>.<target>) encapsulates all the build information for all the
    source directories under bld.<project>/<version>.  All the built targets and build information files go
    into the Bld.<project>/<version> directory.  See 13 below for reasons why recursive make causes problems.
 6. Each source file will have three signatures associated with it - one for the source file, one for the
    corresponding object file and one for the cmds use to rebuild the source.  A change in any of these will
    result in a rebuild.  A change in the target signature will result in a rebuild.  Optionally, the
    signatures of dynamic libraries may be tracked.  If a library signature changes the bld may warn or stop
    the rebuild.  If dynamic libraries are added or deleted from the bld this can ignore/warn/fatal.
 7. If any files in the bld have the same signature this is warned about e.g. two header or source files of
    the same or different names.
 8. Complex multi-target projects are built with a standard directory setup and a standard set of scripts -
    Directories:
        Bld.<project>/<version>       - has all files controlling <project> <version>s blds and bld target output files
        bld.<project>/<version>       - source code for <project> <version>s

    Files:
        bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
        bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
        bld.<project>.targets         - list of all <project> targets
        bld.<project>.README          - <project> README
        bld.<project>.install         - <project> install script
        bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
        Bld.<project>.<target>        - the Bld file for each <project> <target>
        Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
 9. Security - since the signatures of everything(source, objects, libraries, executable) are checked it is
    more difficult to insinuate an exploit into a source, object, library or executable during the build process.
 10. The capture of the full build process in the bld.info, bld.warn and bld.fatal files allows easy access to
     and saving of this information.  For multi-target projects with the target names appended to these files
     it allows quick investigation of the build process of many interrelated targets at the same time.
 11. Perl - since bld is all perl and since all warnings and fatals have the source line number associated with
     them, it is very easy to locate in the souce code the exact location of an error and examine the context
     about which the error occurred and routine that the error was produced in.
 12. Time - programmer time; learning about, maintaining/debugging Makefiles and Makefile hierarchies, dependency
     checking integration and formulation of Makefile strategies, automatic Makefile generation with Autotools -
     these all dominate the programmer time and expense of 'make'.  bld only requires basic perl variables(in
     the Bld file EVAL section) and '[R] dir:regex:{cmds}' line specifications(in the Bld file DIRS section).
 13. 'make' and it's difficulties:
         http://www.scons.org/wiki/FromMakeToScons
             a detailed critique of make and some alternatives
         http://www.scons.org/architecture/
             a description of the scons architecture and in particular the reasons for the use of signatures instead of dates
         ftp://ftp.gnu.org/old-gnu/Manuals/autoconf/html_mono/autoconf.html#SEC3
             a brief critique of make and how GNU automake from the GNU Build System contributes
         http://aegis.sourceforge.net/auug97.pdf
             an article "Recursive Make Considered Harmful" by Peter Miller from the Australian UNIX Users Group
         http://www.conifersystems.com/whitepapers/gnu-make/
             an in depth critique of make

=head1 PROJECT STATE

 State:
 1. The testing is 80%-90% done.
 2. The usage msg is done - the perldoc is 50%-60% done, needs a lot of work.

 Needed:
 1. The git, svn and systemd projects need work.  I ran ./configure before each bld.  I used
    no options.  How options affect the generated code and thus the Bld files is important.
    Anyone willing to investigate configure options and how these options affect the Bld files
    is welcome.

 2. The bld.<project>.install scripts all need to be done.  I'd prefer to partner with someone
    knowledgeable about the installation of git, svn and systemd.

 3. All the Bld.gv.<project> files should be vetted by a <project> knowledgeable builder.

 4. The git, svn and systemd projects will all be creating new versions eventually.  Anyone
    that would like to add bld.<project>/<version> and Bld.<project>/<version> directories
    with the new versions is welcome.

 5. I need someone with substantial experience building the linux kernel to advise me or partner
    with me on the construction of 3.19 or later.

 6. If you successfully bld a new project and wish to contribute the bld, please do so.  I'm 
    interested in how others construct/organize/document/debug projects and their Bld files.

=head1 DESCRIPTION

 bld(1.0.1) is a simple flexible non-hierarchical program that builds a single C/C++/Objective C
 /Objective C++/Assembler target(executable or library(static or shared)) and, unlike 'make', uses SHA1
 signatures(no dates) for building software and GNU cpp for automatic header file dependency
 checking.  The operation of bld depends entirely on the construction of the Bld(bld specification)
 and Bld.gv(bld global values) files.  See the bld.README file.  There are no cmd line arguments or
 options(except for -h(this msg)) or $HOME/.bldrc or ./.bldrc files and no environment variables are
 used.  Complex multi-target projects are bld't with the use of a Bld.<project> (Bld files and
 target bld output files) directory, bld.<project>(project source) directory, bld.<project>(target
 construction) script, bld.<project>.rm(target and bld.<info|warn|fatal>.<target> file removal)
 script, Bld.<project>.gv(project global values) file, bld.<project>.install(target and file
 install) script and bld.<project>.README(project specific documentation) file.  Current example
 projects:

     Bld.git - the git project http://git-scm.com/
     Bld.svn - the subversion project http://subversion.apache.org/
     Bld.systemd - the systemd project http://www.freedesktop.org/wiki/Software/systemd/
     Bld.example - misc examples intended to show how to create Bld and Bld.gv files

 bld is based upon taking the SHA1 signature of anything that, when changed, would require a
 rebuild of the executable/library.  It is not, like 'make', based in any way on dates.  This
 means that source or header files may be moved about, and if the files do not change then
 nothing needs to, or will, be rebuilt.  bld is not hierarchical; all of the information to
 rebuild the executable is contained in the Bld(and Bld.gv) file.  The rebuild is based on Perl's
 regex engine to specify source file patterns along with the Perl eval{} capability to bring
 variable definitions from the Bld file into the source.

 bld reads the Bld file which describes the build.  This example Bld file serves for the
 following discussion:

    Program description and Bld file explanatory comments go here.(and are ignored by bld)
    EVAL
    DIRS

 The Bld file has three sections , a starting comment section to document the Bld, an EVAL and DIRS.
 Variables to be used for interpolation into build commands are defined in the EVAL section.
 The variables are all Perl variables.  The entire EVAL section is eval{}'ed in bld.  Any
 errors will terminate the run.  The DIRS section has three field(: 0) lines which are
 the directory, the matched files to a Perl regular expression, and a build command for the line
 matched files.  EVAL section variable definitions are interpolated into the build commands.
 bld will execute "$cmd $dir/$s"; for each source file, with $cmd from the interpolated third
 field, $dir from the first field, and $s from the matched source second field of the DIRS
 section lines.  Rebuilds will happen only if:

    1. a source file is new or has changed
    2. the corresponding object file is missing or has changed
    3. the command that is used to compile the source has changed
    4. a dependent header file has changed
    5. the command to link the executable or build the library archive has changed
    6. the executable or library has changed or is missing

 The Bld.sig file, automatically built, holds the source/object/header/executable/library file
 names and the corresponding signatures used to determine if a source should be rebuilt the
 next time bld is run.  Normally, system header files are included in the rebuild criteria.
 However, with the -s switch, signature testing of these files can be disabled to improve
 performance.  It is unusual for system header files to change except after a new OS
 installation.

 add description of directory structure - o dir - build dir

=head1 QUICK START

 1. Bld'ing the systemd project - http://www.freedesktop.org/wiki/Software/systemd/
    a. cd Bld.systemd/systemd-208 # puts you into the systemd(systemd-208) project directory
    b. ./bld.systemd --all        # bld's all of the systemd targets and bld target output files -
                                        the bld.info.systemd.<target>,
                                        the bld.warn.systemd.<target>,
                                        the bld.fatal.systemd.<target>,
                                        files
    c. ./bld.systemd.rm --all     # cleans up everything

 2. Bld'ing the svn project - https://subversion.apache.org/
    a. cd Bld.svn/subversion-1.8.5 # puts you into the svn(subversion-1.8.5) project directory
    b. ./bld.svn --all             # bld's all of the svn targets and bld target output files -
                                         the bld.info.svn.<target>,
                                         the bld.warn.svn.<target>,
                                         the bld.fatal.svn.<target>,
                                         files
    c. ./bld.svn.rm --all          # cleans up everything

 3. Bld'ing the git project - http://www.git-scm.com/
    a. cd Bld.git/git-1.9.rc0 # puts you into the git(git-1.9.rc0) project directory
    b. ./bld.git --all        # bld's all of the git targets and bld target output files -
                                    the bld.info.git.<target>,
                                    the bld.warn.git.<target>,
                                    the bld.fatal.git.<target>,
                                    files
    c. ./bld.git.rm --all     # cleans up everything

 4. Bld'ing any single target
    a. cd bld       # the main bld directory - cd here when you unpack the bld.tar.xz file
    b. Install the source code in a sub-directory of the bld directory
    c. Create a Bld file - the Bld file entirely controls the target bld - see example below
    d. ./bld -h     # the bld usage msg
    e. ./bld        # do the bld
    f. ./bld.rm     # clean up
    g. vi Bld.sig   # examine the bld signature file
    h. vi bld.info  # detailed info about the stages of the bld
    i. vi bld.warn  # warning msgs from the bld
    j. vi bld.fatal # fatal msgs that terminated the bld - should be empty if bld is successful

=head1 FILES

 ~/bld directory files:
 bld        - the bld perl script
 bld.rm     - script to clean the bld directory
 bld.README - for first point of contact quick start
 Bld        - the bld file which controls bld and the construction of a target
 Bld.gv     - the file of global values imported into the Bld file(unusually used only for multi-target builds)
 Bld.sig    - the signature(SHA1) file created from the Bld file
 bld.info   - information about the bld 
 bld.warn   - warnings from the bld 
 bld.fatal  - the fatal msg that ended the bld 

 ~/bld directories:
 Bld.<project>/<version> - has all files controlling <project> <version>s blds and bld target output files
 bld.<project>/<version> - source code for <project> <version>s
 aux                     - template scripts for <project> blds

 ~/bld/aux files:
 aux/bld.<project>       - template copied to Bld.<project>/<version> directories to bld multi-target projects
 aux/bld.<project>.rm    - template copied to Bld.<project>/<version> directories to clean multi-target projects

 ~/bld/Bld.<project>/<version> files:
 bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
 bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
 bld.<project>.targets         - list of all <project> targets
 bld.<project>.README          - <project> README
 bld.<project>.install         - <project> install script
 bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
 Bld.<project>.<target>        - the Bld file for each <project> <target>
 Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
 Bld.sig.<project>.<target>    - the signature(SHA1) file for each <project> <target>
 bld.info.<project>.<target>   - the bld.info file for each <project> <target>
 bld.warn.<project>.<target>   - the bld.warn file for each <project> <target>
 bld.fatal.<project>.<target>  - the bld.fatal file for each <project> <target>
 bld.<project>.targets         - all of the <project> targets

=head1 PRIMARY PROGRAM DATA STRUCTURES

 TBD

=head1 NOTES

 1. bld assumes that a source will build a derived file e.g. .o files in the same directory and
    have the same root name as the source.

 2. bld assumes that all targets in multi-target bld's will be uniquely named - all targets go
    into the same project directory.

 3. Some projects violate either or both of these target naming or object file naming/location
    requirements, but reconstructing these projects with bld should be relatively easy
    e.g. systemd.

 4. bld executes cmd fields({}) in the bld directory and then moves all created files to the
    source directory.


    Very old notes - needs updating:

    1. bld uses two adjunct files: Bld and Bld.sig.  The Bld file describes all the sources,
       their locations, and the rules for building them.  Since bld is not hierarchical the
       Bld file is the only place where build information is located.  The Bld file consists
       of two subsection types: EVAL and DIRS.  The file must begin with one EVAL section.
       The EVAL section is Perl code that is eval{}'ed by bld.  Variables that the user wants
       to have interpolated into source file build commands are defined here.  Three variables
       are mandatory: $exec(the executable name), $link(the executable building rule), and
       $libs(the executable libraries spec).  Other variables that are to be used in the
       expansion of source file build commands are defined here.  The EVAL keyword must start
       the line.  An eval{} error in the EVAL section will cause the termination of the
       program.  A DIRS section is specified after the EVAL section and at the end of the Bld
       file.  The DIRS keyword must start the line.  This section consists of whitespace lines,
       which are ignored, and build specification lines with three colon separated fields.  The
       fields are the directory relative to the bld executable directory, a Perl regular
       expression including /'s selecting the source files that this line is to control the
       building of, and the build command for the selected source files.  A directory may have
       several DIRS section lines selecting for different source files with different build
       commands.  Any variables in the build commands are interpolated from variables defined
       in the EVAL section.  All unnecessary whitespace in the command third field of DIRS
       section lines is compressed out.  Thus changing the spacing(spaces, tabs, and \n) of
       the command field will not affect any source rebuild.  If any source file in any of the
       directories is not selected by some regular expression, it is not included in the build.
       A simple and an extended example of Bld files is given below.
    2. The Bld.sig signature file is automatically created and updated.  It contains one line
       for each source, one line for each header file, and one line for the executable.  The
       header file lines and the executable line have two fields: the file name and its
       signature.  The source lines have three or four fields: the file name, the signatures
       of the source file, the command use to build the source, and the object file.  The
       user can modify this file to force the rebuild of files by altering the signature or
       even by deleting a line, however, any modification to a source or header file, or build
       command string will do the same thing.
    3. The user should always run bld -b after completion of a new executable Bld file.
       This option processes the Bld file and prints the expanded build command and all
       source files that each specification line selects for.  Thus, the user can see
       exactly what is going to be included in each build and how all files are going to
       be rebuilt.  Any variables defined for use in the build rules are also printed out.
    4. A bld run may be ^C interrupted.  When a normal uninterrupted run is completed the
       Bld.sig file is rewritten using only those files that were included in the build.
       Thus, if files were added or deleted this would reflect in the new Bld.sig file.  If a
       run is interrupted, all files read in from the original Bld.sig file and any new files
       already built are written out to the Bld.sig file.  This ensures that new files already
       built and old files not yet examined will not be rebuilt.  This may result in some
       entries in the Bld.sig file that no longer exist, but this will be corrected at the end
       of the next normally completed run.
    5. The -h, -r options exit without rebuilding the executable.
    6. In the Bld file anything before the EVAL is ignored.  This allows Bld file explanatory
       comments to be inserted at the start of this file.
    7. There are no imported environment variables.  The mkdir, mv, and cpp commands must
       be accessible, as well as, the commands in $cmd and $link variables.
    8. A non C or C++ source will be rebuilt if its build command has been changed or the
       source file itself has been changed.  The rebuilt output will be put back in the
       directory where the source came from under the assumption that it will be a C file
       that will then need itself to be rebuilt later on in the build sequence.

=head1 Bld FILE FORMAT

 The Bld file(and Bld.gv) controls the entire target bld.  It is divided into three sections -
 Comment(s), EVAL and DIRS:

 Add comments before the EVAL line

 EVAL

 # mandatory defined variables
     $bld="";
     $bldcmd = "";
     $lib_dirs = "";
     $opt_s = "";
     $opt_r = "";
     $opt_lib = "";

 DIRS
 # {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications

 {cmds}
 '[R] dir:regex:{cmds}'
 '[R] dir:regex:{cmds}'
 ...

 1. a comment section

 2. An EVAL(starts a line) section - this is perl code that is eval'ed in bld.  Six variables are required.  These are:
    e.g.

        EVAL
        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        Any other simple perl variables can be defined in the EVAL section and used in the DIRS section.  Environment
        variables may be set.

 3. A DIRS(starts a line) section - this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications.
    The {cmds} blocks are just a group of shell cmds, always executed.  A dir specification is a source directory relative
    to the bld directory.  The regex specification is a perl regular expression that will pick up one or more of the
    source files in dir.  The {cmds} specification describes how to build the selected source files.  Any number of
    cmds, ';' separated, may be specified within the {} brackets.

 Example Bld Files:

    Simplest(Bld.example/example/Bld.example.helloworld-c):

        The 'Hello World!' program with only the minimal required definitions.

        Comment(s)

        EVAL

        $CC = "gcc";

        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="helloworld-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "/usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "warnlibcheck";

        DIRS

        bld.example/example : ^helloworld\.c$ : { $CC -c $s; }


    Complex(Bld.example/example/Bld.example.exec-c):

        A well commented example of all of the features of a Bld file.  The code routines are all just stubs
        designed to illustrate a Bld file.

        Comment(s)

        EVAL
        # this section will define perl variables to be interpolated into DIRS section cmd fields

        # the compiler
        $CC = "clang";

        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        # some examples of variables that will be interpolated into DIRS section cmd fields
        $INCLUDE = "-I bld.example/example/include";
        $LSOPTIONS = "-l";

        # "a" or "b" to conditionally compile main.c
        $COND = "a";

        DIRS
        # this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications

        # example of use of conditional compilation
        bld.example/example/C : ^main\.c$ : {
                                  # can have comments here too
                                  if [ "$COND" == 'a' ];
                                  then
                                      $CC -S $INCLUDE $s;
                                  fi
                                  if [ "$COND" == 'b' ];
                                  then
                                      $CC -O4 -S $INCLUDE $s;
                                  fi
                              }

        # example of execution of a bare block of cmds - '{' and '}' may be on separate lines
        {
            ls $LSOPTIONS;
        }

        # the cmd field may be put on another line(s) and indented
        bld.example/example/C : ^g\.x\.C$ :
            {
                $CC -c $INCLUDE $s;
            }

        # all three fields - dir, regex and cmd - may be put on separate lines(even with extra blank lines).
        # directories may have embedded blanks('a b').
        bld.example/example/C/a b :
        ^m\.c$      :

        {$CC -c $INCLUDE $s;}

        # example of regex field that captures multiple source files(h.c and i.c) and example of a
        # cmd field with multiple cmds - white space is irrelevant(a change should not cause a rebuild)
        # example of cmd fields with multiple cmds(ls and $CC)
        bld.example/example/C     : ^(h|i)\.c$    : {  ls -l $s;  $CC -c $INCLUDE $s;  }

        # example of assembler source
        # Note: the $CC compile produces .o output by changing the c to an o.
        #       the as output needs to be specified by the -o option.
        bld.example/example/C     : ^main\.s$ : {as -c -o main.o $s;}

        bld.example/example/C/ww  : ^u\.c$    : {$CC -c $INCLUDE $s;}

        # example of use of recursive directory search - the same regex and cmd fields
        # are applied to all subdirectories of the specified dir field(right after the 'R')
        R bld.example/example/C/y : ^.*\.c$   : {$CC -c $INCLUDE $s;}

        bld.example/example/C/x   : ^t\.c$    : {$CC -c $INCLUDE $s;}

        bld.example/example/C/z   : ^(w|w1)\.c$    : {$CC -c $INCLUDE $s;}

        # cmd blocks may execute multiple cmds(ls and pwd)
        {
            ls -lfda; pwd;
            ls;
        }

=head1 DIAGNOSTICS

 Warnings(Warning ID(WID)):

 # routine: rebuild_target_bool()
 # ldd return has a library 'not found' entry
 warning("WID 1: ldd return: $libname library is 'not found'");

 # routine: rebuild_target_bool()
 # warn if libraries have been removed from the bld
 warning("WID 2: Libraries removed: @libs_removed") if $opt_lib eq "warnlibcheck";

 # routine: rebuild_target_bool()
 # warn if a library has changed
 warning("WID 3: Library changed: $l") if $opt_lib eq "warnlibcheck";

 # routine: rebuild_target_bool()
 # warn if a library has been added to the bld
 warning("WID 4: Libraries added: @libs_removed") if $opt_lib eq "warnlibcheck";

 # routine: rebuild_exec()
 # ldd return has a library 'not found' entry
 warning("WID 5: ldd return: $libname library is 'not found'");

 # routine: multiple_sigs()
 # if there are multiple source files with the same signature print this header
 $warn = "Multiple source files with the same signature:\n";
 $warn .= "--------------------------------------------------------------------------------------\n";
 warning("WID 6: $warn");

 # routine: multiple_sigs()
 # warn if there are multiple source files with the same signature
 $warn = sprintf "%*d  %s\n", 31, $n, $signature;
 # loop over all source file names with $signature
 foreach my $file ( sort keys %{$SourceSig{$signature}} )
 {
     $warn .= sprintf "%*s\n", 86, $file;
 }
 warning("WID 7: $warn");

 # routine: buildopt()
 # warn if multiple instances of '-c' option detected in {} cmds; this can occur if conditional compilation is used
 warning("WID 8: Multiple instances of '-c' detected in compile options(might just be conditional compilation).\n--->$tmp");

 # routine: buildopt()
 # warn if multiple instances of '-S' option detected in {} cmds; this can occur if conditional compilation is used
 warning("WID 9: Multiple instances of '-S' detected in compile options(might just be conditional compilation).\n--->$tmp");

 # routine: buildopt()
 # warn if multiple instances of '-E' option detected in {} cmds; this can occur if conditional compilation is used
 warning("WID 10: Multiple instances of '-E' detected in compile options(might just be conditional compilation).\n--->$tmp");

 # routine: accum_blddotinfo_output()
 # multiple $s variables specified in {} cmd field - not necessarily a problem
 warning("WID 11: Multiple($n) '\$s' variables specified in DIRS line command field: $cmd_var_sub");

 # routine: accum_blddotinfo_output()
 # the regex field of the cmd line specification did not match any source files
 warning("WID 12: No sources matched in $BGC::BFN DIRS section line $line");

 # routine: accum_blddotinfo_output()
 # warn if a source file does not exist or is not readable
 my $string = sprintf "Source file %s does not exist or is not readable.\n   %4d  %s", $s, $count, $line;
 warning("WID 13: $string");

 # routine: accum_blddotinfo_output()
 # warn and fatal if the same source file has been specified in multiple DIRS regex specifications
 my $string = sprintf "Source file %s specified in more than one DIRS line specification:\n   %s\n   %4d  %s", $s, $s{"$basename"}, $count, $line;
 warning("WID 14: $string");

 # routine: dirs_pro()
 # warn and fatal if any of the following three are detected
 my $msg = "$BGC::BFN DIRS section has one or more of:\n".
    "a. Directory or source file specification cannot be read\n".
    "b. No sources matched\n".
    "c. Multiple build entries matching same source file";
 warning("WID 15: $msg");

 # routine: variable_match()
 # warn if variables defined in the EVAL section are not used in any DIRS section specification
 warning("WID 16: EVAL defined variable(s) not used in DIRS cmds: @evalextra");

 # routine: variable_match()
 # warn and fatal if variables used in the DIRS section specifications are not defined in the EVAL section
 warning("WID 17: DIRS cmd variable(s) not defined in EVAL section: @dirsextra");


 Fatals(Fatal ID(FID)):

 # routine: main bld program block
 # bad option entered - only '-h' allowed
 fatal("FID 1: GetOptions() failed(use bld -h).");

 # routine: main bld program block
 # bld does not take any arguments
 fatal("FID 2: Arguments specified - takes only options.") if @ARGV > 0;

 # routine: Bld_section_extract()
 # missing Bld file
 fatal("FID 3: $BGC::BFN file missing.");

 # routine: Bld_section_extract()
 # the Bld file requires sections separated by a line with EVAL at the beginning followed by a line with DIRS at the beginning
 fatal("FID 4: $BGC::BFN invalid format - need EVAL and DIRS sections.");

 # routine: main bld program block
 # the Bld file EVAL section requires the definition of six variables and optionally any others
 fatal("FID 5: $BGC::BFN EVAL section is empty.");

 # routine: main bld program block
 # the EVAL section is 'eval "@eval";'ed for errors
 fatal("FID 6: $BGC::BFN EVAL section: Fatal eval error: $EVAL_ERROR");

 # routine: main bld program block
 # $opt_s must be either "system" or "nosystem"
 fatal("FID 7: Invalid value for \$opt_s: \'$opt_s\'") if $opt_s ne "system" and $opt_s ne "nosystem";

 # routine: main bld program block
 # $opt_r must be either "rebuild" or "norebuild"
 fatal("FID 8: Invalid value for \$opt_r: \'$opt_r\'") if $opt_r ne "rebuild" and $opt_r ne "norebuild";

 # routine: main bld program block
 # $opt_lib must be either "nolibcheck" or "libcheck" or "warnlibcheck" or "fatallibcheck"
 fatal("FID 9: Invalid value for \$opt_lib: \'$opt_lib\'") if
     $opt_lib ne "nolibcheck" and
     $opt_lib ne "libcheck" and
     $opt_lib ne "warnlibcheck" and
     $opt_lib ne "fatallibcheck";

 # routine: main bld program block
 # $bld, $bldcmd and $lib_dirs are mandatory defines in the EVAL section
 fatal("FID 10: One or more of $BGC::BFN file required variable definitions \$bld, \$bldcmd and \$lib_dirs are missing.");

 # routine: main bld program block
 # $opt_s and $opt_r and $opt_lib are mandatory defines in the EVAL section
 fatal("FID 11: One or more of $BGC::BFN file required variable definitions \$opt_s and \$opt_r and \$opt_lib are missing.");

 # routine: read_Blddotsig()
 # invalid header file or library file SHA1 signature in Bld.sig file
 fatal("FID 12: Malformed $BGC::SIGFN file - invalid SHA1 signature \$sigsource:\n$line");

 # routine: read_Blddotsig()
 # invalid source file SHA1 signature in Bld.sig file
 fatal("FID 13: Malformed $BGC::SIGFN file - invalid SHA1 signature \$sigsource:\n$line");

 # routine: read_Blddotsig()
 # invalid source file build cmd SHA1 signature in Bld.sig file
 fatal("FID 14: Malformed $BGC::SIGFN file - invalid SHA1 signature \$sigcmd:\n$line");

 # routine: read_Blddotsig()
 # invalid source target file SHA1 signature in Bld.sig file
 fatal("FID 15: Malformed $BGC::SIGFN file - invalid SHA1 signature \$sigtarget:\n$line");

 # routine: read_Blddotsig()
 # a line in the Bld.sig file did not match a recognized format
 fatal("FID 16: Malformed $BGC::SIGFN file - invalid format line:\n$line");

 # routine: main bld program block
 # execution of the {} field cmds with system() failed
 fatal("FID 17: Error msg: $error_msg\nCmd: \"$cmd_var_sub\"\nFail status: $status");

 # routine: main bld program block
 # DIRS section lines must be formatted with cmd blocks({}) or three field specification lines('[R] dir:regex:{cmds}')
 fatal("FID 18: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");

 # routine: main bld program block
 # for regexs in DIRS section '[R] dir:regex:{cmds}' specifications the regex must match at lest one source file
 fatal("FID 19: No source file matched in any DIRS section line regular expression.");

 # routine: rebuild_target_bool()
 # if $opt_lib is "libcheck" or "warnlibcheck" or "fatallibcheck" the target must be dynamically linkable
 fatal("FID 20: ldd return: $bld is 'not a dynamic executable'");

 # routine: rebuild_target_bool()
 # a library has been removed from the bld and "fatallibcheck" has been specified
 fatal("FID 21: Libraries removed: @libs_removed") if $opt_lib eq "fatallibcheck";

 # routine: rebuild_target_bool()
 # a library has been changed from the bld and "fatallibcheck" has been specified
 fatal("FID 22: Library changed: $l") if $opt_lib eq "fatallibcheck";

 # routine: rebuild_target_bool()
 # a library has been added from the bld and "fatallibcheck" has been specified
 fatal("FID 23: Libraries added: @libs_removed") if $opt_lib eq "fatallibcheck";

 # routine: rebuild_exec()
 # error detected in rebuilding the target form $bldcmd
 fatal("FID 24: Error msg: $error_msg\nCmd: \"$tmp\"\nFail status: $status");

 # routine: rebuild_exec()
 # doing 'ldd' cmd on the target, $bld, indicated that the target wis not a dynamic executable
 fatal("FID 25: ldd return: $bld is 'not a dynamic executable'");

 # routine: src_pro()
 # wrong number of arguments specified for the src_pro() routine
 fatal("FID 26: src_pro(): wrong number of args") if @_ != 11;

 # routine: src_pro()
 # source files may only have valid file extensions
 fatal("FID 27: Valid file extension not found in $s");

 # routine: src_pro()
 # source files may only have valid file extensions
 fatal("FID 28: $BGC::BFN DIRS section source file $s has no recognizable extension(see %Depend)");

 # routine: buildopt()
 # the source file has an extension that does not match what is expected by the build option
 fatal("FID 29: Invalid combination of source extension: $srcext and build option: -c.");

 # routine: buildopt()
 # two objects files of the same name can't be produced in the same place
 fatal("FID 30: Object file conflict - $s produces an object file $basenametgt that already exists.");

 # routine: buildopt()
 # the source file has an extension that does not match what is expected by the build option
 fatal("FID 31: Invalid combination of source extension: $srcext and build option: -S.");

 # routine: buildopt()
 # the source file has an extension that does not match what is expected by the build option
 fatal("FID 32: Invalid combination of source extension: $srcext and build option: -E.");

 # routine: buildopt()
 # the source file has an extension that does not match what is expected by the build option
 fatal("FID 33: Invalid combination of source extension: $srcext and build option: non of -c/-S/-E exists.");

 # routine: buildopt()
 # only one of options -c/-S/-E may be specified in a cmd field for a source
 fatal("FID 34: Multiple options -c/-S/-E specified in cmd: $cmd_var_sub.");

 # routine: tgtextorfile()
 # multiple target files in the $srcpath directory.  if more than one target file do fatal().
 fatal("FID 35: More than one target file for $srcfile in $srcpath: @tgtfiles");

 # routine: src_pro()
 # execution of the {} field cmds with system() failed
 fatal("FID 36: Error msg: $error_msg\nCmd: \"$cmd_var_sub\"\nFail status: $status");

 # routine: src_pro()
 # execution of the {} field cmds with system() failed to produce any new target files
 fatal("FID 37: No new target files created by command:\nCmd: \"$cmd_var_sub\"");

 # routine: tgt_signature()
 # execution of the {} field cmds with system() failed to produce any new target files
 fatal("FID 38: No target file for $srcfile in $srcpath: @tgtfiles");

 # routine: tgt_signature()
 # check for multiple target files created by $cmd_var_sub
 fatal("FID 39: More than one target file for $srcfile in $srcpath: @tgtfiles");

 # routine: tgt_signature()
 # two target files of the same name and location cannot be created
 fatal("FID 40: An identical target file(name) has been created twice: ${srcpath}$tgtfiles[0]");

 # routine: src_pro()
 # moving all new files in the bld directory created by "$cmd_var_sub" execution
 # to the directory of the $s source failed
 fatal("FID 41: Error msg: $error_msg\n\"mv $newfile $srcpath\" fail status: $status");

 # routine: dirs_pro()
 # Bld file DIRS section cannot be empty
 fatal("FID 42: $BGC::BFN DIRS section is empty.");

 # routine: cvt_dirs_to_array()
 # Bld file DIRS section line should be a cmd block({}) but does not match this pattern
 fatal("FID 43: $BGC::BFN DIRS section line is not valid(doesn't match $BGC::RGX_CMD_BLOCK): $line");

 # routine: cvt_dirs_to_array()
 # Bld file DIRS section lines must be formatted with cmd blocks({}) or three field specification lines('[R] dir:regex:{cmds}')
 fatal("FID 44: $BGC::BFN DIRS section line is not valid(doesn't match $BGC::RGX_VALID_DIRS_LINE): $dir_regex.$line");

 # routine: cvt_dirs_to_array()
 # Bld file DIRS section lines must be formatted with cmd blocks({}) or three field specification lines('[R] dir:regex:{cmds}')
 fatal("FID 45: $BGC::BFN DIRS section line is not valid(doesn't match $BGC::RGX_VALID_DIRS_LINE): $line");

 # routine: dirs_pro()
 # Bld file DIRS section cannot be empty
 fatal("FID 46: $BGC::BFN DIRS section is empty.");

 # routine: dirs_pro()
 # a formatting error was detected in a DIRS section line; must be cmd block({}) or one '[R] dir:regex:{cmds}'
 fatal("FID 47: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");

 # routine: accum_blddotinfo_output()
 # Bld file DIRS section directory specifications must have valid chars
 fatal("FID 48: Bad(really weird) char(not $BGC::RGX_VALID_PATH_CHARS) in directory specification: $dir");

 # routine: accum_blddotinfo_output()
 # do eval {} on regex to determine if regex is valid
 fatal("FID 49: Invalid regular expression - \"$regex_srcs\".");

 # routine: accum_blddotinfo_output()
 # each Bld file DIRS section cmd field must have at least on '$s' source file specification
 fatal("FID 50: No '\$s' variable specified in DIRS line command field: $cmd_var_sub");

 # routine: accum_blddotinfo_output()
 # source files may only have valid file extensions
 fatal("FID 51: Valid file extension not found in $s");

 # routine: accum_blddotinfo_output()
 # source files may only have valid file extensions
 fatal("FID 52: $BGC::BFN DIRS section source file $s has no recognizable extension(see %Depend)");

 # routine: accum_blddotinfo_output()
 # a formatting error was detected in a DIRS section line; must be cmd block({}) or one '[R] dir:regex:{cmds}'
 fatal("FID 53: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");

 # routine: dirs_pro()
 # Bld DIRS section has one or more of:
 #     a. Directory or source file specification cannot be read
 #     b. No sources matched
 #     c. Multiple build entries matching same source file
 fatal("FID 54: $msg   - see $BGC::BWFN.\n");

 # routine: variable_match()
 # the scalar variable '$s' may never be specified in the EVAL section
 fatal("FID 55: The scalar variable \$s may not be specified in the EVAL section, as this is used in the DIRS".
       " section command field to signify matched source files.");

 # routine: variable_match()
 # a formatting error was detected in a DIRS section line; must be cmd block({}) or one '[R] dir:regex:{cmds}'
 fatal("FID 56: $BGC::BFN DIRS section line is incorrectly formatted(see $BGC::BIFN): $line");

 # routine: variable_match()
 # variables used in DIRS section cmd fields but not defined in the EVAL section
 fatal("FID 57: Extra unused variable(s) in DIRS section - see $BGC::BWFN.");

 # routine: hdr_depend()
 # doing the 'cpp' cmd on a source file failed
 fatal("FID 58: $cpperror");

 # routine: file_sig_calc()
 # file to calculate signature of does not exist
 fatal("FID 59: File: $filename does not exit.");

 # routine: file_sig_calc()
 # error on open attempt of Bld file
 fatal("FID 60: File: open() error on $filename.");

 # routine: file_sig_calc()
 # can't take a signature of a zero length file
 fatal("FID 61: File: $filename is of zero size - a useful signature cannot be taken of an empty file.");

 # routine: sourcesort()
 # the regex's for valid source, header or library files do not match
 fatal("FID 62: Invalid source format - $a");

 # routine: sourcesort()
 # the regex's for valid source, header or library files do not match
 fatal("FID 63: Invalid source format - $b");

 # routine: sourcesort()
 # the regex for valid file extensions did not match
 fatal("FID 64: Valid file extension not found in $basea");

 # routine: sourcesort()
 # the regex for valid file extensions did not match
 fatal("FID 65: Valid file extension not found in $baseb");

=head1 TODO/CONTEMPLATE/INVESTIGATE/EXAMINE/CHECKOUT/THINK ABOUT/HACK ON

   Software Development:

 . write executable to compare Bld.sig signatures with Bld.<project>/<version> source for security
   purposes.  with Bld.sig protected then sofware build is protected.  write executable to do
   Bld.sig signature compare against source for all the targets in a project build.

 . investigate `cd Bld.systemd/systemd-208; ldd ` cd before ldd

 . investigate elimination of -L(use lib_dirs?) option in Bld.<project>.<target> files

 . check: is $lib_dirs working? does this require a full path? 

 . Bld.example/example/Bld.example.rdx-c - mod rdx to delete() and search() on from one to n keys
       - do not require the full set of keys - should be easy

 . Use Modern::Perl with bld

 . Use Find::File::Rule and File::Slurp in bld

   Test:

 . bld - allow compile of a group od 1 or more *.c files without building an exec or library
 . bld - install kernel - think about automation of 'make V=1' to Bld file
 . test execution of arbitrary perl code in Bld.<project>.gv and EVAL sections
 . do a 'make V-1 install' in the git project and see what it takes to install git
 . add new version of one of git/subversion/systemd to show how multiple versions of <project> are bld't
 . run on Mac
 . test library changes
 . investigate running under the debugger and profiling
 . Unit Tests:
      . empty Bld file
      . Bld file with both, in order, EVAL and DIRS lines
      . EVAL section is correct(required variables) and DIRS section is empty
      . EVAL section is empty(required variables) and DIRS section is correct(non-empty)
      . EVAL section is empty(required variables) and DIRS section is empty

   Doc:

 . Doc that bld has no inherent built in rules
 . add security info
 . add explanation of aux directory
 . go thru code line by line and do code scrub, comment scrub and make list of features and advantages
 . do bld perldoc
 . doc extensions.pl and clang-gcc-headers.pl
 . Bld file with only a {} block will execute the block but fail because of no .o files to build the target
 . make list of install component requirements:
       1. experimental.pm
       2. gcc/clang
 . add note that two project builds cannot run at the same time - Bld.sig and Bld.gv files
 . add Note about if two targets are built from the same source files - they both use the same .o files
       and may compile different .o files depending on the compile options - this results in the building
       of one target interfering with the build of the other target since the signature of the .o files
       are now different because of the other build.
 . add doc/notes about ldd and env variable LD_LIBRARY_PATH - add code to add special paths to LD_LIBRARY_PATH??
 . doc packages needed for execution of all Bld.example's :
       clang(LLVM), gcc, g++, GNUstep header of the GNUstep Base library package
 . add perldoc section on how to use bld to build a multi executable/library project e.g. subversion
 . major routine call tree
 . explain modules to install and all build/run requirements
       experimental.pm
       gcc/g++
       clang
       ldd
 . required executables are available and full paths - operation: ldd, cpp, mv, which - build: gcc, g++, clang, as
       add doc with list of all external cmds
 . FFAQ - (Fake)FAQ
 . add section on design notes - section on design philosophy
 . write subroutines summary
 . add doc about the 6 required variables and how to construct them

   Outside resources:

 . read Intermediate Perl 2nd Ed for ideas
 . investigate scons on scons.tigres.org
 . read "Managing Projects with GNU Make"
 . Links:
     . http://www.scons.org/wiki/FromMakeToScons
     . http://producingoss.com/ - Carl Fogel
     . http://coding.smashingmagazine.com/2013/01/03/starting-open-source-project/
     . http://oss-watch.ac.uk/resources/howtobuildcommunity

   Release:

 . on release ask for users to compile new projects and incorporate them into a Release bld.<project>.<version>.tar.gx file
 . slide presentation
 . article
 . LLVM community
 . GNU community
 . Contribute to Free Software Foundation
 . 37signals.com
 . Apache Software Foundation
 . send the perlbrew team a copy
 . CPAN.org
 . hunspell

   Notes:

 . to do a forced rebuild of everything delete Bld.sig or *.o
 . note on how to build both static and dynamic libraries
 . why no 'include' DIRS directive?
 . exit codes 0=success, 255=error - see bld.*
 . EVAL section %@ defines are ignored - only scalar variables - $cmd to EVAL 0
 . if a source is moved it will rebuild since the Bld.sig signature is keyed to the source
       file and it's path from the bld parent directory
 . same basename with different extensions will fail and same basename with same extension
       in different locations will fail because same named object will be created
 . symbolic links to source files should work - a file in one place and a link to that same
       file in another place will be detected/warned/fatal
 . g++ is installed with the gcc-c++ package

   Consult:

 . open source release consult??

=head1 INCOMPATIBILITIES

 None Known

=head1 BUGS AND LIMITATIONS

 None Known

=head1 SEE ALSO

 bld.README

 Critique of 'make':
     http://www.scons.org/wiki/FromMakeToScons
         a detailed critique of make and some alternatives
     http://www.scons.org/architecture/
         a description of the scons architecture and in particular the reasons for the use of signatures instead of dates
     ftp://ftp.gnu.org/old-gnu/Manuals/autoconf/html_mono/autoconf.html#SEC3
         a brief critique of make and how GNU automake from the GNU Build System contributes
     http://aegis.sourceforge.net/auug97.pdf
         an article "Recursive Make Considered Harmful" by Peter Miller from the Australian UNIX Users Group
     http://www.conifersystems.com/whitepapers/gnu-make/
         an in depth critique of make

=head1 GITHUB RELEASES

 https://github.com/rahogaboom/bld
     bld-1.0.0.tar.gz - initial release
         bld.git.git-1.9.rc0.tar.gz
         bld.svn.subversion-1.8.5.tar.gz
         bld.systemd.systemd-208.tar.gz
 
=head1 AUTHOR

 Richard A Hogaboom
 richard.hogaboom@gmail.com

=head1 LICENSE and COPYRIGHT and (DISCLAIMER OF) WARRANTY

Copyright (c) 1998-2014, Richard A Hogaboom
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. :-)

