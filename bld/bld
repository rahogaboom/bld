#!/usr/bin/perl


# LICENSE and COPYRIGHT and (DISCLAIMER OF) WARRANTY

# Copyright (c) 1998-2015, Richard A Hogaboom - richard.hogaboom@gmail.com
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.

# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.

# * Neither the name of the {organization} nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. :-)


#
# bld - a simple flexible non-hierarchical program that uses SHA1 signatures
#       to build a single target(executable or library(static or shared)).
#       Complex multi-target projects may be built with the help of the
#       bld.<project> and bld.<project>.rm scripts and uses standard <project>
#       directory structures for the placement of code and Bld files. see
#       bld.README.  do "bld -h" for command help or "perldoc bld" for the
#       full man page
#

# use modern perl
use 5.018.4;

#
# standard modules
#

use warnings;
use diagnostics;
use autodie;
use English;
use Getopt::Long;
use File::Find;
use Data::Dumper;

# extract_multiple - for parsing the $BFN DIRS section
# extract_bracketed - used by extract_multiple for finding '{}''s
use Text::Balanced qw(
                         extract_multiple
                         extract_bracketed
                     );

# sha1_hex - the bld program SHA1 generator
use Digest::SHA qw(
                      sha1_hex
                  );

#
# installed modules
#

#use Modern::Perl 2014;

# this module allows the use of experimental perl language features(given, when, ~~) without generating warnings.
# to see exactly where smartmatch features are being used just comment out this line.  bld will run, but with warnings
# everyplace an experimental smartmatch feature is used.
use experimental 'switch';

use lib "./modules";
use BGC;
use BldRoutines;

# START: main bld program block
{
    my
    (
        # file related
        @eval,    # contents of the $BFN file EVAL section
        $dirs,    # contents of the $BFN file DIRS section before \s+ compression
        @dirs,    # contents of the $BFN file DIRS section after \s+ compression

        $opt_h,   # -h cmd line help option, do ./bld -h

        $comment_section, # holds comment section in Bld file for printing in $BIFN file

        # mandatory variable definitions in the EVAL section of $BFN
            $bld,        # the target to build e.g. executable, libx.a, libx.so
            $bldcmd,     # cmd used in perl system() call to build $bld object - requires '$bld' and '$O'(object files) internally
            $lib_dirs,   # space separated list of directories to search for libraries

            # mandatory option related in the EVAL section of $BFN
                $opt_s,     # to use system header files in dependency checking("system" or "nosystem")
                $opt_r,     # to inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
                $opt_lib,   # to do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")

        # booleans
        $rebuild_chgsrc, # boolean to indicate a source file has changed
        $rebuild_nosrc,  # boolean to indicate a(any) source file has been deleted
        $rebuild_target, # boolean to indicate the target has:
                         #     1. target is missing
                         #     2. signature of target does not exist in $SIGFN signature file
                         #     3. signature of target exists in signature file but is changed from actual existing target

        # primary program data structures
            %Sigdata,
                # signature data and build target library dependency data
                #
                # the hash will be two levels(for source file signature, build cmd signature and build target signature data):
                # $Sigdata{<full path or relative path file source>}[<$SIG_SRC or $SIG_CMD or $SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $SIG_SRC - source signature e.g. signature of 'source.c' or 'header.h' or 'libx.so'
                #         2. $SIG_CMD - build cmd signature e.g. signature of 'clang -c source.c -lm'
                #         3. $SIG_TGT - target signature e.g. signature of 'source.o'
                #     c. the values are signatures
                #
                # Example: # signature of source file
                #          $Sigdata{'src/C/main.c'}[$SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $Sigdata{'src/C/main.c'}[$SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $Sigdata{'src/C/main.c'}[$SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $Sigdata{'/usr/include/wchar.h'}[$SIG_SRC] = '587c23d7ebd0856b9a9a59c8b0c6469bf0c75963';
                #
                #          # signature of relative path header file
                #          $Sigdata{'src/C/head.h'}[$SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                #          # signature of build target
                #          $Sigdata{'exec-c'}[$SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for build target library file dependency data):
                # $Sigdata{<build target>}[<$LIB_DEP>]{<library file name>} = undef
                #     a. the first level hash has a key of the build target file name e.g. exec-c
                #     b. the second level array has an index values of $LIB_DEP - a library dependency e.g. libm.so
                #     c. the third level hash has a key of the library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $Sigdata{'exec-c'}[$LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $Sigdata{'exec-c'}[$LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                # Purpose: holds $SIGFN file signature data read in at program start for comparison to %SigdataNew program calculated data to
                #          determine what, if anything, to re-build

            %SigdataNew,
                # signature and dependency information
                #
                # the hash will have two levels(for signature data):
                # $SigdataNew{<full path or relative path file source>}[<$SIG_SRC or $SIG_CMD or $SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $SIG_SRC - source signature e.g. signature of source.c or header.h or libx.so
                #         2. $SIG_CMD - build cmd signature e.g. signature of "clang -c source.c -lm"
                #         3. $SIG_TGT - target signature e.g. signature of source.o
                #     c. the values are signatures
                #
                # Example: # library signature
                #          $SigdataNew{'/lib64/libc.so.6'}[$SIG_SRC] = '7c135fc5b3aca5ef9064bdbd51608cf1aad6feee';
                #
                #          # build target signature
                #          $SigdataNew{'exec-c'}[$SIG_SRC] = '95b0de6b76a336aed5bfb1a5fa1d757ccf1eabfc';
                #
                #          # signature of source file
                #          $SigdataNew{'src/C/main.c'}[$SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $SigdataNew{'src/C/main.c'}[$SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $SigdataNew{'src/C/main.c'}[$SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $SigdataNew{'/usr/include/stdc-predef.h'}[$SIG_SRC] = '51eecd0afe5466d0ea173369fbe0c91657f92d53';
                #
                #          # signature of relative path header file
                #          $SigdataNew{'src/include/head.h'}[$SIG_SRC] = 'i7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for header file or library file dependency data):
                # $SigdataNew{<full path or relative path file source>}[<$HDR_DEP or $LIB_DEP>]{<file name>} = undef
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of two index values:
                #         1. $HDR_DEP - a header dependency - the source depends on a header e.g. header.h
                #         2. $LIB_DEP - a library dependency - the $bldcmd for the $bld target depends on a library e.g. libm.so
                #     c. the third level hash has a key of the header or library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $SigdataNew{'exec-c'}[$LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $SigdataNew{'exec-c'}[$LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # source file full path header dependency
                #          $SigdataNew{'src/C/main.c'}[$HDR_DEP]{'/usr/include/_G_config.h'} = undef;
                #
                #          # source file relative path header dependency
                #          $SigdataNew{'src/C/main.c'}[$HDR_DEP]{'src/C/l.hh'} = undef;
                #
                # Purpose: holds program calculated data - command, source, header, library and target file signature data as well as source file header dependencies and build
                #          cmd library dependencies.  data in this structure is compared with data in the %Sigdata structure to determine what, if anything, to re-build.  just
                #          before program exit the $SIG_SRC, $SIG_CMD and $SIG_TGT signatures of %SigdataNew are written to $SIGFN and becomes the %Sigdata for the next run.

            %Objects,
                # object files
                #
                # the hash will be one level:
                # $Objects{<relative path object file>} = undef
                #     a. the keys are the object file relative path name starting from the bld home directory e.g. src/somefile.o
                #     b. the values are undef
                #
                # Example: # the tt.o object file
                #          $Objects{"\'src/C/y/tt.o\'"} = undef;
                #
                #          # the main.o object file
                #          $Objects{"\'src/C/main.o\'"} = undef;
                #
                #          Note: the inclusion of literal single quotes around the source to avoid problems with directories that have embedded spaces
                #
                # Purpose: used in the $bldcmd required variable to build the $bld target

            %SourceSig,
                # source file signatures - signatures for all source files(code or header) or libraries in the build
                #
                # the hash will be two levels:
                # $SourceSig{'<signature>'}{'<full path or relative path file source>'} = undef
                #     a. the first level hash has a key of the source signature e.g. signature of source.c or header.h or libx.so
                #     b. the second level hash has a key of the full or relative path file
                #     c. the values are undef
                #
                # Example: # w.c has same signature as w1.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w.c'} = undef;
                #
                #          # w1.c has same signature as w.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w1.c'} = undef;
                #
                #          # main.c has a unique signature
                #          $SourceSig{'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5'}{'src/C/main.c'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/../include/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/include/head.h'} = undef;
                #
                # Purpose: if %SourceSig has, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
                #          then there is a source or library of the same signature in two different places

            %Targets,
                # target files - relative path(from the bld directory)
                #
                # the hash will be one level:
                # $Targets{'<relative path file target>'} = undef
                #     a. the first level hash has a key of the relative path(from the bld directory) build file target e.g. src/C/main.o(from main.c) or src/C/lex.c(from lex.l)
                #     b. the values are undef
                #
                # Example: # build target of m.c source
                #          $Targets{'src/C/a b/m.o'} = undef;
                #
                #          # build target of main.c source using gcc
                #          $Targets{'src/C/main.o'} = undef;
                #
                #          # build target of main.c source using as
                #          $Targets{'src/C/main.s'} = undef;
                #
                # Purpose: for each source picked up by a DIRS section regex and built by the corresponding cmd a single target file will be produced.
                #          these files in relative path form from the build directory are used as hash keys.  if two identical target file names are created
                #          (both path and file name) they would overwriting one another.  as targets are added to the build, a new hash key that
                #          already exists will fatal().  if a source is not re-built then it will not be added to %Targets.  only re-built targets are added.
    );

    # initially interrupts just fatal(); after the $BFN file has been processed and the $SIGFN has been read in, int_sig_handler()
    # will handle them and first write out any partially accumulated new signatures to $SIGFN and then fatal().
    local $SIG{INT} = sub {
                              my (
                                     $signame,
                                 ) = @_;

                                 fatal("\nInterrupted with signal $signame");
                          };

    GetOptions
    (
        "h" => \$opt_h,
    ) or fatal("FATAL: GetOptions() failed(use bld -h).");

    if ( @ARGV > 0 )
    {
        my $msg = sprintf "FATAL: Arguments specified - takes only options.";
        fatal($msg);
    }

    # help msg
    opt_help() if $opt_h;

    {
        # clear $BIFN, $BWFN and $BFFN files

        open my $bifnfh, ">", $BIFN;
        close $bifnfh;
        open my $bwfnfh, ">", $BWFN;
        close $bwfnfh;
        open my $bffnfh, ">", $BFFN;
        close $bffnfh;
    }

    # scan $BFN file accumulating EVAL lines(in @eval) and DIRS lines(in $dirs) for later processing.
    my ( @tmp ) = Bld_section_extract();
    $comment_section = shift @tmp;
    $dirs = pop @tmp;
    @eval = @tmp;

    if ( @eval == 0 )
    {
        my $msg = sprintf "FATAL: %s EVAL section is empty.", $BFN;
        fatal($msg);
    }

    {
        # if a $BGVFN file exists read in as an array and prepend to the @eval array.
        # this allows the $BGVFN file to serve as a source of global variable defines.

        my @bldrc;

        # slurp in $BGVFN file to array
        if ( -f "$BGVFN" and -r "$BGVFN" )
        {
            open my $bldrcfh, "<", "$BGVFN";
            @bldrc = <$bldrcfh>;
            close $bldrcfh;
        }

        unshift @eval, @bldrc;
    }

    {
        # eval() the EVAL section code of the $BFN file.  this must be 'no strict' or
        # interpolation will complain about undefined variables.

        no strict;
        eval "@eval";
        use strict;

        # check for syntax errors($@).  see perldoc.perl.org -> perlvar -> $EVAL_ERROR
        if ( $EVAL_ERROR )
        {
            my $msg = sprintf "FATAL: %s EVAL section: Fatal eval error: %s", $BFN, $EVAL_ERROR;
            fatal($msg);
        }

        if ( $opt_s ne "system" and $opt_s ne "nosystem" )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_s: \'%s\'", $opt_s;
            fatal($msg);
        }
        if ( $opt_r ne "rebuild" and $opt_r ne "norebuild" )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_r: \'%s\'", $opt_r;
            fatal($msg);
        }
        if (
               $opt_lib ne "nolibcheck" and
               $opt_lib ne "libcheck" and
               $opt_lib ne "warnlibcheck" and
               $opt_lib ne "fatallibcheck"
           )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_lib: \'%s\'", $opt_lib;
            fatal($msg);
        }
    }

    if ( not defined $bld or not defined $bldcmd or not defined $lib_dirs )
    {
        my $msg = sprintf "FATAL: One or more of %s file required variable definitions \$bld, \$bldcmd and \$lib_dirs are missing.", $BFN;
        fatal($msg);
    }

    if ( not defined $opt_s or not defined $opt_r or not defined $opt_lib )
    {
        my $msg = sprintf "FATAL: One or more of %s file required variable definitions \$opt_s and \$opt_r and \$opt_lib are missing.", $BFN;
        fatal($msg);
    }

    $bld =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{\s+}{ }g; # compress white space to a single space
    $lib_dirs =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $lib_dirs =~ s{\s+}{ }g; # compress white space to a single space

    # if "nosystem" remove library search directories that start with '/'
    if ( $opt_s eq "nosystem" )
    {
        my @tmp = grep { /^[^\/]/ } split /\s+/, $lib_dirs;
        $lib_dirs = join $SPACE, @tmp;
    }

    # write initial info to the bld.info file
    init_blddotinfo( $bld, $bldcmd, $lib_dirs, $opt_s, $opt_r, $opt_lib, $comment_section );

    # process $BFN file DIRS section
    @dirs = dirs_pro( $dirs, $opt_s );

    # scan EVAL and DIRS sections for variables.  if variables in EVAL but not in DIRS do warning().
    # if variables in DIRS but not in EVAL do fatal().
    variable_match( \@eval, \@dirs );

    # read $SIGFN file data into %Sigdata
    read_Blddotsig( $bld, \%Sigdata );

    # enable ^C interruption
    local $SIG{INT} = \&int_sig_handler;

    # 
    # Usage      : ^C
    #            : kill INT => $PID;
    #
    # Purpose    : interrupt handler, not called directly, but by the program receiving at INT signal.
    #            : this may happen in two ways - a. a ^C is typed at the keyboard during program execution and
    #            : b. during a call to the fatal() routine.  fatal() prints it's calling msg to the $BFFN file
    #            : and then signals an INT to the program.
    #
    # Parameters : called with the SIG name of the interrupt
    #
    # Returns    : fatal()
    #
    # Globals    : %Sigdata
    #            : %SigdataNew
    #
    # Throws     : None
    #
    # Notes      : None
    #
    # See Also   : None
    #
    sub int_sig_handler
    {
        #requires global variables:
        my (
               $signame,
           ) = @_;

        %SigdataNew = ( %SigdataNew, %Sigdata );

        sig_file_update( $bld, \%SigdataNew );

        fatal("\nInterrupted with signal $signame");
    }


    #
    # CHECK COMPILATION UNITS
    #

    # boolean to indicate that any source file was re-built and thus $bld will need re-building
    $rebuild_chgsrc = "false";

    # for each directory line in $BFN, check sources and if needed re-build with $cmd
    # for that directory.  a source file will be re-built if a $SIGFN file signature entry
    # does not exist for this source file, indicating a new source file, or the source
    # file signature has changed.

    foreach my $line ( @dirs )
    {
        given ( $line )
        {
            when ( m{$RGX_CMD_BLOCK} )
            {
                my ( $cmd, $cmd_var_sub );

                # DIRS section cmd block
                $cmd = $line;

                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                # interpolate perl variables in $cmd
                $cmd_var_sub = var_sub( $cmd );

                if ( $cmd_var_sub ne $EMPTY )
                {
                    my ( $status, $error_msg );

                    # convert '!!!' strings back to newlines for execution
                    $cmd_var_sub =~ s{!!!}{\n}g;

                    # execute $cmd_var_sub's
                    $status = system "$cmd_var_sub";

                    if ( $status != 0 )
                    {
                        $error_msg = system_error_msg( $CHILD_ERROR, $ERRNO );

                        my $msg = sprintf "FATAL: Error msg: %s\nCmd: \"%s\"\nFail status: %s", $error_msg, $cmd_var_sub, $status;
                        fatal($msg);
                    }
                }

                print "{$cmd_var_sub}\n";
                next;
            }
            when ( m{$RGX_VALID_DIRS_LINE} )
            {
                my ( $dir, $regex_srcs, $cmd );

                # DIRS section three field specification line - '[R] dir:regex:{cmds}'

                # split dir lines on ":" and remove $regex_srcs enclosing '{' and '}', and $cmd enclosing '{' and '}'
                ($dir, $regex_srcs, $cmd) = split $COLON, $line;

                # add double quotes around the source file $s in order to handle spaces in the file name
                $cmd =~ s{\$s}{"\$s"}g;

                $regex_srcs =~ s{^\{|\}$}{}g; # remove $regex_srcs regex delimiters
                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                # interpolate perl variables in $dir
                $dir = var_sub( $dir );

                opendir my ( $dirfh ), $dir;

                # a. read $dir directory b. select only ordinary files that match $regex_srcs c. map files to relative path name
                my @Sources = map { "$dir/$_" } grep { $_ =~ m{$regex_srcs} and -f "$dir/$_" } readdir $dirfh;
                closedir $dirfh;

                foreach my $s ( @Sources )
                {
                    my ( $cmd_var_sub, $truefalse );

                    # find perl variables in $cmd and substitute EVAL section values for these variables
                    # and substitute the $s variable from the @Sources array.
                    # NOTE: do 'perldoc -q "How can I expand variables in text strings"' to see a discussion
                    #       of how this(s{}{}gee) works and possible alternatives.

                    $cmd_var_sub = $cmd;
                    no strict;
                    $cmd_var_sub =~ s{(\$$RGX_PERL_VARIABLE)}{$1}gee;
                    use strict;

                    $truefalse = src_pro( $s, $cmd_var_sub, $bld, $opt_s, $opt_r, \%Sigdata, \%Depend, \%SigdataNew, \%SourceSig, \%Objects, \%Targets );

                    # if any $s needs re-building set $rebuild_chgsrc to "true"
                    if ( $truefalse eq "true" )
                    {
                        $rebuild_chgsrc = "true";
                    }
                } # END: foreach my $s (@Sources){}
            }
            default
            {
                my $msg = sprintf "FATAL: %s DIRS section line is incorrectly formatted(see %s): %s", $BFN, $BIFN, $line;
                fatal($msg);
            }
        }
    } # END: foreach my $line ( @dirs ){}

    if ( not %Objects )
    {
        my $msg = sprintf "FATAL: No source file matched in any DIRS section line regular expression.";
        fatal($msg);
    }


    #
    # CHECK TARGET AND REBUILD IF NECESSARY
    #

    # boolean indicating to re-build target if any of three conditions is true:
    #     1. target is missing
    #     2. signature of target does not exist in $SIGFN signature file
    #     3. signature of target exists in signature file but is changed from actual existing target
    $rebuild_target = rebuild_target_bool( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Sigdata, \%SigdataNew );

    # if a(any) source has been deleted($s exists in %Sigdata and does not exist in %SigdataNew) then force re-build
    $rebuild_nosrc = "false";
    foreach my $s ( keys %Sigdata )
    {
        if ( not $s ~~ %SigdataNew )
        {
            $rebuild_nosrc = "true";
        }
    }

    # re-build if:
    #     1. a source file of executable has changed($rebuild_chgsrc)
    #     2. or a source file has been deleted($rebuild_nosrc)
    #     3. or the target is has any of the three conditions listed above($rebuild_target)
    if ( $rebuild_chgsrc eq "true" or $rebuild_nosrc eq "true" or $rebuild_target eq "true" )
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that would be re-built, but do not re-build
            print "---WILL--- be re-built: $bld\n";
        }
        else
        {
            rebuild_exec( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Objects, \%SigdataNew );
        }
    }
    else
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that will not be re-built
            print "$bld will NOT be re-built.\n";
        }
        else
        {
            print "$bld is up to date.\n";
        }
    }

    # DEBUG
    # if debugging, for dumping the primary program data structures
=for
    print "DEBUG:\n";
    print Data::Dumper->new([\%Depend],[qw(\%Depend)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Sigdata],[qw(\%Sigdata)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SigdataNew],[qw(\%SigdataNew)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Objects],[qw(\%Objects)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SourceSig],[qw(\%SourceSig)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Targets],[qw(\%Targets)])->Indent(3)->Quotekeys(0)->Dump;
    print "ENDDEBUG:\n";
=cut

    # if %SourceSig, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
    # then there is a source or library of the same signature in two different places
    multiple_sigs( \%SourceSig );

    # if $opt_r option is "norebuild" do not re-build - do not touch $SIGFN file
    if ( $opt_r eq "norebuild" ) { exit 0; }

    # ignore interrupts while $SIGFN is being written
    local $SIG{INT} = 'IGNORE';

    # writes %SigdataNew signature data to $SIGFN and header/code file inventory to $BIFN
    sig_file_update( $bld, \%SigdataNew );

    exit 0;
}
# END: main bld program block


#
# SUBROUTINES SECTION - Global data dependent(only var_sub())
#
#     Note: The global data is all of the variables imported from the EVAL section of the $BFN file by the eval "" of that section
#


# 
# Usage      : $cmd_var_sub = var_sub( $cmd );
#            :     - note: called in scalar context
#            : %dirs_vars_tmp = var_sub( $cmd, '$s' );
#            :     - note: called in list context
#            : %eval_vars = var_sub( $eval_vars, '$bld', '$bldcmd', '$lib_dirs', '$O', '$opt_s', '$opt_r', '$opt_lib' );
#            :     - note: called in list context
#
# Purpose    : depending on the calling context do:
#            :     1. scalar context - simple variable($name) substitution and return the substituted string.
#            :     2. list context - create a hash of string,
#            :        for $a = 1 - key = 'simple variable name($a -> 'a')'/value = 'simple variable value(1)',
#            :        entries and return the hash.
#            : exclude from processing the list of variable entries after the $cmd input string.
#            : the return depends on calling context(see wantarray()).
#
# Parameters : $cmd     - command string
#            :            Note: $cmd may have embedded newlines.  this is OK as m{\$($RGX_PERL_VARIABLE)}g should match newlines.
#            :
#            : @exclude - list of variables to exclude from substitution - applies to both $cmd and %h returns.
#            :            these variables may be specified either with or without the leading '$' sign. e.g. '$bld' or 'bld'
#
# Returns    :     1. if wantarray is false:
#            :            do variable substitution on $cmd, excepting variable names
#            :            passed in the @exclude array, and return it
#            :     2. if wantarray is true:
#            :            extract variable names from $cmd and build a hash with variable names
#            :            as keys and values as the values of those variables - return that hash
#
# Globals    : All of the variables imported from the EVAL section by the eval "" of that section
#
# Throws     : None
#
# Notes      : 1. the exclude list may have variables listed without the scalar variable prefix $ sign e.g. 'bld'.  however,
#            :    '$bld' seems better because it reminds the user that the exclude list is a list of variables.
#            : 2. the @exclude arguments must not be interpolated - thus they should be of the form '$string' with single quotes
#            : 3. ignore entirely any %hash variables($hash{a}) or @array variables($array[0]) -
#            :    these may be used freely in the EVAL section
#
# See Also   : perldoc -f wantarray
#
sub var_sub
{
    my (
           $cmd,
           @exclude,
       ) = @_;

    # hash with variable/variable value
    my ( %h );

    # for return type
    my ( $wantarray );


    $wantarray = wantarray();

    foreach my $exclude ( @exclude )
    {
        $exclude =~ s{^\$}{}; # strip leading '$' sign
    }

    # find all(except from @exclude) simple perl variables($name) and, depending on the calling context,
    # either substitute their values or build a hash with variable/variable value entries.  ignore
    # entirely any %hash variables($hash{a}) or @array variables($array[0])
    while ( $cmd =~ m{ \$($RGX_PERL_VARIABLE) }gx )
    {
        my $varmatch = $1;

        # if $varmatch is in @exclude skip it
        last if $varmatch ~~ @exclude;

        no strict;
        if ( $wantarray )
        {
            $h{"\$$varmatch"} = ${$varmatch};
        }
        else
        {
            $cmd =~ s{\$$varmatch}{${$varmatch}};
        }
        use strict;
    }

    return $wantarray ? %h : $cmd;
}

1;

__END__

=head1 NAME

 bld

=head1 VERSION

 bld version 1.0.4

=head1 USAGE

 usage: bld [-h]
     -h          - this message.(exit)

=head1 ARGUMENTS

 None

=head1 OPTIONS

bld [-h]

-h
        help message(exit)

=head1 ENVIRONMENT VARIABLES

 None

=head1 RC CONFIGURATION FILES

 None

=head1 DESCRIPTION

 bld(1.0.4) is a simple flexible non-hierarchical program that builds a single C/C++/Objective C
 /Objective C++/Assembler target(executable or library(static or shared)) and, unlike 'make', uses
 SHA1 signatures(no dates) for building software and GNU cpp for automatic header file dependency
 checking.  The operation of bld depends entirely on the construction of the Bld(bld specification)
 and Bld.gv(bld global values) files.  See the bld.README file.  There are no cmd line arguments or
 options(except for -h) or $HOME/.bldrc or ./.bldrc files and no environment variables are
 used. A bld.rm program is provided to clean up the main bld directory.

 bld is based upon taking the SHA1 signature of anything that, when changed, would require a
 re-build of the executable/library.  It is not, like 'make', based in any way on dates.  This
 means that source or header files may be moved about, and if the files do not change then
 nothing needs to, or will, be re-built.  bld is not hierarchical; all of the information to
 re-build the executable is contained in the Bld(and Bld.gv) file.  Bld can descend recursively
 to pick up and build source, however, the specification for this is still in the Bld file at
 the top of the source tree.

 Complex multi-target projects are built with the use of a Bld.<project> (Bld files and target
 bld output files) directory, bld.<project>(project source) directory, bld.<project>(target
 construction) script, bld.<project>.rm(target and bld.<info|warn|fatal>.<target> file removal)
 script, Bld.<project>.gv(project global values) file, bld.<project>.install(target and file
 install) script and bld.<project>.README(project specific documentation) file.  Current example
 projects:

     git     - the git project http://git-scm.com/
     svn     - the subversion project http://subversion.apache.org/
     systemd - the systemd project http://www.freedesktop.org/wiki/Software/systemd/
     example - misc examples intended to show how to create Bld and Bld.gv files

 To understand the bld'ing of a single target the following should be understood:

     ~/bld directory files:
     bld        - the bld perl script
     bld.rm     - script to clean the bld directory
     bld.README - for first point of contact quick start
     Bld        - the bld file which controls bld and the construction of a target
     Bld.gv     - the file of global values imported into the Bld file
                      (unusually used only for multi-target builds)
     Bld.sig    - the signature(SHA1) file created from the Bld file
     bld.info   - information about the bld 
     bld.warn   - warnings from the bld 
     bld.fatal  - the fatal msg that ended the bld 

 The Bld file(and Bld.gv) controls the entire target bld.  The Bld file is divided into three
 sections - Comments, EVAL and DIRS:

 ##################################################
 Comments - Add comments before the EVAL line

 EVAL
 # add perl variables to be used in the DIRS section 'dir' or {cmds} parts.  six are mandatory.

 $PROJECT = "git";
 $CC = "clang";
 $INCDIR = "test/include";

 # optional variables e.g. $CCOPT = "-O";

 # mandatory defined variables

     # the target to build e.g. executable, libx.a, libx.so
     $bld="exec-c";

     # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
     $bldcmd = "$CC $INCDIR -lm -o \$bld \$O";

     # space separated list of directories to search for libraries
     $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

     # use system header files in dependency checking("system" or "nosystem")
     $opt_s = "system";

     # inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
     $opt_r = "rebuild";

     # do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")
     $opt_lib = "fatallibcheck";

 DIRS
 # '{cmds}' cmd blocks e.g. {ls;pwd;date;}
 # or
 # '[R] dir:regex:{cmds}' specifications e.g. bld.$PROJECT/git-2.3.0/:^zlib\.c$:{gcc $INCDIR -o zlib.o $s}
 # see examples below in 'Bld FILE FORMAT AND EXAMPLES'.  both 'dir' and '{cmds}' fields below may have EVAL
 # defined variables interpolated into them.

 {cmds}
 [R] dir:regex:{cmds}
 {cmds}
 [R] dir:regex:{cmds}
 [R] dir:regex:{cmds}
 ...
 ...
 
 ##################################################

 The Bld file has three sections, a starting comments section to document the Bld, an EVAL
 section to define variables(and Bld.gv defined variables read in at the beginning of the
 EVAL section) for interpolation into DIRS section 'dir' and '{cmds}' fields and a DIRS
 section that defines either {cmd} blocks or '[R] dir:regex:{cmds}' specifications.  The
 entire EVAL section is eval{}'ed in bld.  Any errors will terminate the run.  There are
 six mandatory variables(see above). The {cmd} blocks just execute a group of shell cmds.
 The '[R] dir:regex:{cmds}' specifications are used to build source, located in directories
 below the bld directory. These specifications are composed of three fields:

     [R] dir - a directory with possibly variables to be interpolated and [R] if a recursive
               search for source is to be made.

     regex   - a perl regular expression to match sources to be built by the {cmds} field.  if
               [R] is specified then this same regex will be applied to every directory
               recursively searched.  the same {cmds} are applied to every source found.

     {cmds}  - a group of cmds to construct all the source files selected by the regex field.
               {cmds} will be executed successively for each source matched.  the cmds should
               have at least one '$s' variable specified.  each of the matched source files
               will be substituted for '$s'.


 Rebuilds will happen if:

     1. a source file is new or has changed
     2. the corresponding object file is missing or has changed
     3. the command that is used to compile the source has changed
     4. a dependent header file has been added/deleted or changed
     5. the command to link the executable or build the library archive has changed
     6. the executable or library has changed or is missing


 The execution of bld will produce four files:

     Bld.sig
         The Bld.sig file, holds the source/object/header/executable/library file names and
         corresponding signatures and build cmd signatures used to determine if a source should
         be re-built.  System header files and libraries may optionally be included.

     bld.info
         Contains detailed information about the the stages of the build.

         1. date/time, OS version, compiler version, cpp version etc.
         2. comments section of Bld file
         3. EVAL section expansion of $bld, $bldcmd and $lib_dirs mandatory variables($O is object files)
         4. Bld file DIRS section specification lines with irrelevant white space compressed out
         5. R recursively expanded and numbered DIRS section specification lines
         6. a. DIRS section specification lines
                b. variable interpolated(except for $s) specification line cmd field
                    c. matching compilation unit source file(s)
                        d. source file header dependencies
         7. EVAL section expansion of defined variables used in DIRS section cmd fields
         8. List of all build - System headers(full path)
                                User headers(relative path)
                                System libraries(full path)
                                User libraries(relative path)
                                Source files(relative path)
                                Build target(bld directory)

     bld.warn
        Warnings about the build e.g. multiple copies of the same header files in different
        directories,  multiple '$s' variables specified in DIRS line command field,
        same source file specified in more than one directory, EVAL defined variables
        not used in DIRS cmds.  Each warning will include the package, filename and
        source line etc.

     bld.fatal
        Fatals terminate the build e.g. Same source file \'$basename\' specified in same
        directory, extra unused variable(s) in DIRS section etc.  These files should be
        empty if everything built correctly.


 The six mandatory EVAL defined variables are:

     1. $bld

         # the target to build e.g. executable, libx.a, libx.so
         $bld="exec-c";

     2. $bldcmd

         # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
         $bldcmd = "$CC $INCDIR -lm -o \$bld \$O";

     3. $lib_dirs

         # space separated list of directories to search for libraries
         $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

     4. $opt_s

         # use system header files in dependency checking("system" or "nosystem")
         $opt_s = "system";

     5. $opt_r

         # inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
         $opt_r = "rebuild";

     6. $opt_lib

         # do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")
         $opt_lib = "fatallibcheck";


 To understand the bld'ing of complex multi-target projects the following directories and files should be understood:

     ~/bld directories:
     Bld.<project>/<version> - has all files controlling <project> <version>s blds and bld target output files
     bld.<project>/<version> - source code for <project> <version>s
     aux                     - template scripts directory for <project> blds

     ~/bld/aux files:
     aux/bld.<project>       - template copied to Bld.<project>/<version> directories to bld multi-target projects
     aux/bld.<project>.rm    - template copied to Bld.<project>/<version> directories to clean multi-target projects

     ~/bld/Bld.<project>/<version> files:
     bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
     bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
     bld.<project>.targets         - list of all <project> targets
     bld.<project>.README          - <project> README
     bld.<project>.install         - <project> install script
     bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
     Bld.<project>.<target>        - the Bld file for each <project> <target>
     Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
     Bld.sig.<project>.<target>    - the signature(SHA1) file for each <project> <target>
     bld.info.<project>.<target>   - the bld.info file for each <project> <target>
     bld.warn.<project>.<target>   - the bld.warn file for each <project> <target>
     bld.fatal.<project>.<target>  - the bld.fatal file for each <project> <target>

 The previous description material focused on the construction of a single target.  This requires only
 the use of the bld program and Bld file.  To bld complex multi-target projects requires use of some
 standard directory structure conventions, several programs for bld'ing targets and cleaning project
 directories and directory/file naming conventions.  For example, using git-2.3.0 and a <project> name
 of 'git':

     Bld.git/git-2.3.0
         All of the target Bld files and bld run output files are here.  During development the initiation
         of target re-blds or full project re-blds are initiated from here.

     bld.git/git-2.3.0
         The git-2.3.0.tar.gz file is unzipped here and ./configure is run against the git project source code.

     aux
         Template scripts for use in the Bld.git/git-2.3.0 directory.  The bld.<project> script is copied
         to Bld.git/git-2.3.0 as bld.git.  The bld.<project>.rm is copied to Bld.git/git-2.3.0 as bld.git.rm.
         No changes are required to the scripts code.

     aux/bld.git
         The bld.<project> file would be copied to Bld.git/git-2.3.0 as bld.git.  There is no need to change
         the file; the file name is picked up internally.  This is the main project bld script.  It is
         executed either with a sequence of target names or with '--all' for building all targets. Do
         'perldoc bld.git' for the man page.

     aux/bld.git.rm
         The bld.<project>.rm file would be copied to Bld.git/git-2.3.0 as bld.git.rm.  There is no need to change
         the file; the file name is picked up internally.  This script is used to remove build files related to
         specific targets or clean files related to all targets.  It is executed either with a sequence of target
         names or with '--all' for cleaning all targets.  For example, if test-wildmatch is used as a target then
         the following files will be removed:
             bld.fatal.git.test-wildmatch
             bld.info.git.test-wildmatch
             bld.warn.git.test-wildmatch
             Bld.sig.git.test-wildmatch
             test-wildmatch

         The target Bld file, Bld.git.test-wildmatch, will not be removed. Do 'perldoc bld.git.rm' for the
         man page.

     bld.git.targets
         All the project targets go here, one to a line.  The targets will be built in order from top to bottom.
         Make sure than libraries that are required by subsequent targets are built first.  The file may have
         any number of blank or comment lines.

     bld.git.README
         The bld.git.README file provide getting started and contact information.

     bld.git.install
         For installing the project.  This most likely will be a script to create an installable package. 
         At present none are populated.

     bld.git.script.<script>
         These are scripts to call from the Bld files that do various functions required for target
         construction.  There may be any number of these.  The git project did not require any.

     Bld.git.<target>
         The Bld file for a specific target.

     Bld.gv.git
         The project global values file.  This file is imported at the beginning of every project target
         Bld file.  It has no structure.  It contains defined variables that are common to all project
         Bld files e.g. $CC.

     Bld.sig.git.<target>
     bld.info.git.<target>
     bld.warn.git.<target>
     bld.fatal.git.<target>
         See above for a description of these files.

     See BUILDING MULTI-TARGET PROJECTS below for the detail steps in building complex multi-target projects.

=head1 FEATURES AND ADVANTAGES

  1. Everything is done with SHA1 signatures.  No dates are used anywhere.  Signatures are a property of the
     file and not meta data from the system used for the build.  Any time issues, whether related to local
     clocks, networked host clocks or files touched by command activities are eliminated.  Modern signature
     algorithms are strongly randomized even for small file changes - for the 160 bit SHA1 hash collisions are
     unlikely in the extreme.  The Digest::SHA module is fast.  The expense of signature calculation times 
     is small relative to the expense of programmer time.  An investigation of some other make alternatives
     e.g. scons, cook - will disclose that they too are using signatures - maybe for exactly for the same reasons.
  2. bld is REALLY simple to use.  There are no arguments, no options(except -h), no environment variables and
     no rc files.  The entire bld is controlled from the Bld(and Bld.gv file) file.  Only a minimal knowledge
     of perl is needed - variable definitions and simple regular expressions.
  3. Automatic dependency checking - GNU cpp is used to find the header file dependencies.  Optionally, header
     file checking may be done for user header files only or for simultaneously both system header and user
     header files.  All header file dependency information associated with each source is saved to the
     bld.info file.
  4. There are no built in dependency rules.  The Bld file DIRS section specifications give what is to be
     built from what and the Bld file EVAL section gives how to assemble all the components for the target.
  5. bld is not hierarchical.  A single Bld file controls the construction of a single target(a target is an
     executable or library(static or shared)).  Complex multi-target projects use one Bld.gv(global values)
     file and many Bld files - one to a target.  The source directory structure goes under bld.<project>/<version>
     and each target Bld file(Bld.<project>.<target>) encapsulates all the build information for all the
     source directories under bld.<project>/<version>.  All the built targets and build information files go
     into the Bld.<project>/<version> directory.  See "'make' and it's difficulties:" below for reasons why
     recursive make causes problems.
  6. Each source file will have three signatures associated with it - one for the source file, one for the
     corresponding object file and one for the cmds use to re-build the source.  A change in any of these will
     result in a re-build.  A change in the target signature will result in a re-build.  Optionally, the
     signatures of dynamic libraries may be tracked.  If a library signature changes the bld may warn or stop
     the re-build.  If dynamic libraries are added or deleted from the bld this can ignore/warn/fatal.
  7. If any files in the bld have the same signature this is warned about e.g. two header or source files of
     the same or different names.
  8. Complex multi-target projects are built with a standard directory setup and a standard set of scripts -
     Directories:
         Bld.<project>/<version>       - has all files controlling <project> <version>s blds and bld target output files
         bld.<project>/<version>       - source code for <project> <version>s

     Files:
         bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
         bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
         bld.<project>.targets         - list of all <project> targets
         bld.<project>.README          - <project> README
         bld.<project>.install         - <project> install script
         bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
         Bld.<project>.<target>        - the Bld file for each <project> <target>
         Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
  9. Security - since the signatures of everything(source, objects, libraries, executable) are checked it is
     more difficult to insinuate an exploit into a source, object, library or executable during the build process.
 10. The capture of the full build process in the bld.info, bld.warn and bld.fatal files allows easy access to
     and saving of this information.  For multi-target projects with the target names appended to these files
     it allows quick investigation of the build process of many interrelated targets at the same time.
 11. Perl - since bld is all perl and since all warnings and fatals have the source line number associated with
     them, it is very easy to locate in the souce code the exact location of an error and examine the context
     about which the error occurred and routine that the error was produced in.
 12. Time - programmer time; learning about, maintaining/debugging Makefiles and Makefile hierarchies, dependency
     checking integration and formulation of Makefile strategies, automatic Makefile generation with Autotools -
     these all dominate the programmer time and expense of 'make'.  bld only requires basic perl variables(in
     the Bld file EVAL section) and '[R] dir:regex:{cmds}' line specifications(in the Bld file DIRS section).
 13. 'make' and it's difficulties:
         http://www.scons.org/wiki/FromMakeToScons
             a detailed critique of make and some alternatives(Adrian Neagu)
         http://freecode.com/articles/what-is-wrong-with-make
             What is Wrong with Make?(Adrian Neagu)
         http://www.scons.org/architecture/
             a description of the scons architecture and in particular the reasons for the use of signatures instead of dates
         ftp://ftp.gnu.org/old-gnu/Manuals/autoconf/html_mono/autoconf.html#SEC3
             a brief critique of make and how GNU automake from the GNU Build System contributes
         http://aegis.sourceforge.net/auug97.pdf
             an article "Recursive Make Considered Harmful" by Peter Miller from the Australian UNIX Users Group
         http://www.conifersystems.com/whitepapers/gnu-make/
             an in depth critique of make
         http://www.conifersystems.com/whitepapers/gnu-make/
             What's Wrong With GNU make?
         http://www.leosimons.com/2006/bettermake/what-is-a-better-make.html
             What is a better make?
         http://www.leosimons.com/2006/a-better-make.html
             Building a better (make|ant|maven|...)

=head1 DEPENDENCIES

    I use Fedora for development on an x86_64 architecture.  Yum is the package installation tool.

    Required for execution:
        experimental.pm(3pm) - for smartmatch and switch features
        cpp(1) - gnu cpp cmd is required for dependency determination
        ldd(1) - used for library dependency determination

        Do: cpan install cpanm
            cpanm experimental.pm

    Required for test:
        gcc(1)/g++(1) (http://gcc.gnu.org/)
        clang(1) (http://llvm.org/)
        yacc(1)/flex(1)

    Some variation might be required on(for git, svn, systemd test):
        yum install gcc.x86_64
        yum install gcc-c++.x86_64
        yum install gcc-objc.x86_64
        yum install gcc-objc++.x86_64
        yum install libobjc.x86_64
        yum install gnustep-base.x86_64
        yum install gnustep-base-devel.x86_64
        yum install clang
        yum install byacc
        yum install flex
        yum install zlib-devel.x86_64
        yum install libxdiff.x86_64
        yum install apr.x86_64
        yum install apr-util.x86_64
        yum install apr-util-devel.x86_64
        yum install sqlite-devel.x86_64
        yum install intltool
        yum install libcap-devel
        yum install gtk-doc
        yum install lzma.x86_64
        yum install libmount-devel.x86_64

    If ./configure generates the following msg about missing requirements:

        "configure: error: Package requirements (foo) were not met:

        No package 'foo' found

        Consider adjusting the PKG_CONFIG_PATH environment variable if you
        installed software in a non-standard prefix."

    Do: yum install "pkgconfig(foo)"

    Also check: http://who-t.blogspot.com/2014/05/configure-fails-with-no-package-foo.html

    If the downloaded project code does not have a configure script then check for a configure.ac
    file and run 'autoconf' with no arguments or options.  This will generate a configure script.

=head1 PROJECT STATE

 1. The git, svn and systemd projects need work.  I ran ./configure before each bld.  I used
    no options.  How options affect the generated code and thus the Bld files is important.
    Anyone willing to investigate configure options and how these options affect the Bld files
    is welcome.

 2. The bld.<project>.install scripts all need to be done.  These scripts need to build the
    the packages that 'yum install <package>' would install or possibly packages tailored to
    other systems.  I'd prefer to partner with someone knowledgeable about the installation
    of git, svn and systemd.

 3. All the Bld.gv.<project> files should be vetted by a <project> knowledgeable builder.

 4. The git, svn and systemd projects will all be creating new versions eventually.  Anyone
    that would like to add bld.<project>/<version> and Bld.<project>/<version> directories
    with the new versions is welcome.

 5. I need someone with substantial experience building the linux kernel to advise me or
    partner with me on the construction of 4.0 or later.

 6. If you successfully bld a new project and wish to contribute the bld, please do so.  I'm 
    interested in how others construct/organize/document/debug projects and their Bld files.

=head1 QUICK START

 1. Bld'ing the systemd project - http://www.freedesktop.org/wiki/Software/systemd/
    a. cd Bld.systemd/systemd-208 # puts you into the systemd(systemd-208) project directory
    b. ./bld.systemd --all        # bld's all of the systemd targets and bld target output files -
                                        the bld.info.systemd.<target>,
                                        the bld.warn.systemd.<target>,
                                        the bld.fatal.systemd.<target>,
                                        files
    c. ./bld.systemd.rm --all     # cleans up everything

 2. Bld'ing the svn project - https://subversion.apache.org/
    a. cd Bld.svn/subversion-1.8.11 # puts you into the svn(subversion-1.8.11) project directory
    b. ./bld.svn --all              # bld's all of the svn targets and bld target output files -
                                          the bld.info.svn.<target>,
                                          the bld.warn.svn.<target>,
                                          the bld.fatal.svn.<target>,
                                          files
    c. ./bld.svn.rm --all           # cleans up everything

 3. Bld'ing the git project - http://www.git-scm.com/
    a. cd Bld.git/git-2.3.0 # puts you into the git(git-2.3.0) project directory
    b. ./bld.git --all      # bld's all of the git targets and bld target output files -
                                  the bld.info.git.<target>,
                                  the bld.warn.git.<target>,
                                  the bld.fatal.git.<target>,
                                  files
    c. ./bld.git.rm --all   # cleans up everything

 4. Bld'ing any single target
    a. cd bld       # the main bld directory - cd here when you unpack the bld.tar.xz file
    b. Install the source code in a sub-directory of the bld directory
    c. Create a Bld file - the Bld file entirely controls the target bld - see example below
    d. ./bld -h     # the bld usage msg
    e. ./bld        # do the bld
    f. ./bld.rm     # clean up
    g. vi Bld.sig   # examine the bld signature file
    h. vi bld.info  # detailed info about the stages of the bld
    i. vi bld.warn  # warning msgs from the bld
    j. vi bld.fatal # fatal msgs that terminated the bld - should be empty if bld is successful

=head1 Bld FILE FORMAT AND EXAMPLES

 A more detailed description of the Bld(and Bld.gv) files initially presented in the DESCRIPTION section
 above is presented here.

 1. A comments section

 2. An EVAL(starts a line) section - this is perl code that is eval'ed in bld.  Six variables are required.  These are:
    e.g.

        EVAL
        # mandatory defined variables

            # the target to build e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        Any other simple perl variables can be defined in the EVAL section and used in the DIRS section.  Environment
        variables may be set.

 3. A DIRS(starts a line) section - this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications.
    The {cmds} blocks are just a group of shell cmds, always executed.  A dir specification is a source directory relative
    to the bld directory.  The regex specification is a perl regular expression that will pick up one or more of the
    source files in dir.  The {cmds} specification describes how to build the selected source files.  Any number of
    cmds, ';' separated, may be specified within the {} brackets.

 Example Bld Files:

    Simplest(Bld.example/example/Bld.example.helloworld-c):

        The 'Hello World!' program with only the minimal required definitions.

        Comments

        EVAL

        $CC = "gcc";

        # mandatory defined variables

            # the target to build e.g. executable, libx.a, libx.so
            $bld="helloworld-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "/usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "warnlibcheck";

        DIRS

        bld.example/example : ^helloworld\.c$ : { $CC -c $s; }


    Complex(Bld.example/example/Bld.example.exec-c):

        A well commented example of all of the features of a Bld file.  The code routines are all just stubs
        designed to illustrate a Bld file.

        Comments

        EVAL
        # this section will define perl variables to be interpolated into DIRS section cmd fields

        # the compiler
        $CC = "clang";

        # mandatory defined variables

            # the target to build e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require re-building, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        # some examples of variables that will be interpolated into DIRS section cmd fields
        $INCLUDE = "-I bld.example/example/include";
        $LSOPTIONS = "-l";

        # "a" or "b" to conditionally compile main.c
        $COND = "a";

        DIRS
        # this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications

        # example of use of conditional compilation
        bld.example/example/C : ^main\.c$ : {
                                  # can have comments here too
                                  if [ "$COND" == 'a' ];
                                  then
                                      $CC -S $INCLUDE $s;
                                  fi
                                  if [ "$COND" == 'b' ];
                                  then
                                      $CC -O4 -S $INCLUDE $s;
                                  fi
                              }

        # example of execution of a bare block of cmds - '{' and '}' may be on separate lines
        {
            ls $LSOPTIONS;
        }

        # the cmd field may be put on another line(s) and indented
        bld.example/example/C : ^g\.x\.C$ :
            {
                $CC -c $INCLUDE $s;
            }

        # all three fields - dir, regex and cmd - may be put on separate lines(even with extra blank lines).
        # directories may have embedded blanks('a b').
        bld.example/example/C/a b :
        ^m\.c$      :

        {$CC -c $INCLUDE $s;}

        # example of regex field that captures multiple source files(h.c and i.c) and example of a
        # cmd field with multiple cmds - white space is irrelevant(a change should not cause a re-build)
        # example of cmd fields with multiple cmds(ls and $CC)
        bld.example/example/C     : ^(h|i)\.c$    : {  ls -l $s;  $CC -c $INCLUDE $s;  }

        # example of assembler source
        # Note: the $CC compile produces .o output by changing the c to an o.
        #       the as output needs to be specified by the -o option.
        bld.example/example/C     : ^main\.s$ : {as -c -o main.o $s;}
        # are applied to all subdirectories of the specified dir field(right after the 'R')
        R bld.example/example/C/y : ^.*\.c$   : {$CC -c $INCLUDE $s;}

        bld.example/example/C/x   : ^t\.c$    : {$CC -c $INCLUDE $s;}

        bld.example/example/C/z   : ^(w|w1)\.c$    : {$CC -c $INCLUDE $s;}

        # cmd blocks may execute multiple cmds(ls and pwd)
        {
            ls -lfda; pwd;
            ls;
        }

=head1 FILES

 ~/bld directory files:
 bld        - the bld perl script
 bld.rm     - script to clean the bld directory
 bld.README - for first point of contact quick start
 Bld        - the bld file which controls bld and the construction of a target
 Bld.gv     - the file of global values imported into the Bld file(unusually used only for multi-target builds)
 Bld.sig    - the signature(SHA1) file created from the Bld file
 bld.info   - information about the bld 
 bld.warn   - warnings from the bld 
 bld.fatal  - the fatal msg that ended the bld 

 ~/bld directories:
 Bld.<project>/<version> - has all files controlling <project> <version>s blds and bld target output files
 bld.<project>/<version> - source code for <project> <version>s
 aux                     - template scripts directory for <project> blds

 ~/bld/aux files:
 aux/bld.<project>       - template copied to Bld.<project>/<version> directories to bld multi-target projects
 aux/bld.<project>.rm    - template copied to Bld.<project>/<version> directories to clean multi-target projects

 ~/bld/Bld.<project>/<version> files:
 bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
 bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
 bld.<project>.targets         - list of all <project> targets
 bld.<project>.README          - <project> README
 bld.<project>.install         - <project> install script
 bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
 Bld.<project>.<target>        - the Bld file for each <project> <target>
 Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
 Bld.sig.<project>.<target>    - the signature(SHA1) file for each <project> <target>
 bld.info.<project>.<target>   - the bld.info file for each <project> <target>
 bld.warn.<project>.<target>   - the bld.warn file for each <project> <target>
 bld.fatal.<project>.<target>  - the bld.fatal file for each <project> <target>

=head1 BUILDING SINGLE TARGETS
    (a target is an executable or library(static or shared))

    1. Construct the Bld file - see below for a Bld file example and see the Bld.example
       directory for multiple examples.  A Bld.gv file is not needed for a single target.
       Since there are no args or options to bld and no environment variables or rc files
       are used, nothing else needs to be done.

    2. Execute './bld'.  This will rebuild the target and create/update the Bld.sig signature
       file.  The bld.info, bld.warn and bld.fatal files will be created.

    3. Use './bld.rm' to clean the bld directory.

=head1 BUILDING MULTI-TARGET PROJECTS
    (a target is an executable or library(static or shared))

    1. Pick a name for the project e.g. git, svn, systemd.

    2. In the main bld directory(the location of the bld script) create a bld.<project>
       directory.  Create another directory, bld.<project>/<version>, that describes the
       version of the code it will hold e.g. systemd-208.  Any number of these version
       directories may be created to maintain different versions of the code.  Unpack the
       source code in the version directory e.g. bld.systemd/systemd-208/<systemd-208 src code>.

    3. Create a Bld.<project> directory.  Create another directory, Bld.<project>/<version>,
       that describes the version of the code it will maintain e.g. systemd-208.  There
       should be one version directory for each version of the code being maintained.
       These directories will hold:
           a. all of the Bld.<project>.<target> and Bld.gv.<project> files that control the
              construction of each project target
           b. all of the target bld output files:
                  bld.info.<project>.<target>(information describing the bld)
                  bld.warn.<project>.<target>(bld warning msgs)
                  bld.fatal.<project>.<target>(bld fatal msgs)
           c. the bld scripts and script control files
           d. all of the targets

    4. Create a Bld.<project>.<target> file for each project target.  These control the bld
       for each and only that target.  If there are variables that may be defined globally
       over the entire project then set them in the Bld.gv.<project>(one per project) file.  
       The Bld.gv.<project> file will be included in each Bld.<project>.<target> file before
       it is evaluated.  All Bld.<project>.<target> files require six variables to be defined.
       These are:

       e.g.
       # mandatory defined variables

           # space separated list of directories to search for libraries
           $lib_dirs = ""; 

           # use system header files in dependency checking("system" or "nosystem")
           $opt_s = "nosystem";

           # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
           $opt_r = "rebuild";

           # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
           $opt_lib = "nolibcheck";

           # the target to built e.g. executable, libx.a, libx.so
           $bld="accelerometer";

           # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
           $bldcmd = "$CC $LIBSLINKOPTS -o \$bld \$O -LBld.systemd/systemd-208 -ludev -lsystemd-shared -ludev-core -lm -lrt -ldl";

       The definition of these variables may be spread between the Bld.<project>.<target> and the imported Bld.gv.<project> files.
       See the Bld FILE FORMAT section below for detailed instructions on Bld file construction.


    5. Create a bld.<project>.targets file with all of the project target names, one to a line.
       e.g.

           # each line is a valid target argument to bld.<project> e.g. './bld.<project> target'
           # and will build one(that named) library or executable.  the order of target bld's
           # is important.  if 'bld.<project> --all' is used to bld all targets then dependencies
           # must be built first, that is, libraries that executables depend on must be built at
           # the start.

           # 
           libsystemd-shared.a

           # 
           libsystemd-login.so

           # 
           systemd-cgls

           ...

       The order is important; if an executable depends on a library then build the library first.

    6. Copy the 'bld.<project>' and 'bld.<project>.rm' files from the aux directory to the source code
       directory and rename them for that particular project.  These scripts use the <project> part
       of the script name for building output files.

    7. Run the ./bld.<project> script with the --all option or one or more target names from the bld.<project>.targets file.
       This will bld all targets or the selected targets.  The:

       bld.info.<project>.<target>(information describing the bld)
       bld.warn.<project>.<target>(bld warning msgs)
       bld.fatal.<project>.<target>(bld fatal msgs)

       files will be created.  Examine these for the results of each target bld.  All of the  bld.fatal.<project>.<target>
       files should be empty if everything bld's OK.

    9. Run './bld.<project> --all' again to rebuild.  If everything built successfully the first time then this run
       will indicate that everything is up to date.

    8. Use './bld.<project>.rm [--all] [target, target, ...]' to clean up.

    9. Use './bld.<project>.install' as root to install the project.

    10. Examine the ./bld.<project>.README for project specific information.

=head1 NOTES

 1. bld assumes that a source will build a derived file e.g. .o files in the same directory and
    have the same root name as the source.  a subsequent Bld file {} block can rename and move
    the .o files.

 2. bld assumes that all targets in multi-target bld's will be uniquely named - all targets go
    into the same project directory before distribution for installation.  installation can
    then rename and distribute targets in any way desired.

 3. Some projects(rarely) violate either or both of these target naming or object file
    naming/location requirements, but reconstructing these projects with bld should be
    relatively easy e.g. systemd.

 4. bld executes cmd fields({}) in the bld directory and then moves all created files to the
    source directory.

 5. A bld run may be ^C interrupted.  When a normal uninterrupted run is completed the
    Bld.sig file is rewritten using only those files that were included in the build.
    Thus, if files were added or deleted this would reflect in the new Bld.sig file.  If a
    run is interrupted, all files read in from the original Bld.sig file and any new files
    already built are written out to the Bld.sig file.  This ensures that new files already
    built and old files not yet examined will not be re-built.  This may result in some
    entries in the Bld.sig file that no longer exist, but this will be corrected at the end
    of the next normally completed run.

 6. The Bld.sig signature file is automatically created and updated.  It contains one line
    for each source, one line for each header file, optionally one line for each library and
    one line for the executable.  The header file lines and the executable line have two
    fields: the file name and its signature.  The source lines have four fields: the file
    name, the signatures of the source file, the command use to build the source, and the
    object file.  The user can modify this file to force the re-build of files by altering
    the signature or even by deleting a line, however, any modification to a source or header
    file, or build command string will do the same thing.  Removing the Bld.sig file will
    re-build the entire target.

 7. A non C or C++ source will be re-built if its build command has been changed or the
    source file itself has been changed.  The re-built output will be put back in the
    directory where the source came from. The assumption is that it will be a file that will
    then act a source for subsequent build steps e.g. a lex or yacc that will produce a C
    file as output which will then later need to be compiled.  Bld file cmd({}) blocks can
    modify this.

=head1 CALL TREE

 Calls to imported functions from public CPAN modules are omitted.  Calls to some bld
 coded routines are omitted:
     opt_help()
     system_error_msg()
     warning()
     fatal()
     sourcesort()

 bld
     Bld_section_extract()
     init_blddotinfo()
     dirs_pro()
         cvt_dirs_to_array()
         expand_R_specification()
         accum_blddotinfo_output()
            var_sub()
            var_sub()
            var_sub()
     variable_match()
         var_sub()
         var_sub()
         var_sub()
     read_Blddotsig()
     var_sub()
     var_sub()
     src_pro()
         file_sig_calc()
         buildopt();
         tgtextorfile();
         hdr_depend()
         file_sig_calc()
         rebuild_src_bool()
         tgt_signature()
     rebuild_target_bool()
         file_sig_calc()
         file_sig_calc()
     rebuild_exec()
         file_sig_calc()
         file_sig_calc()
     multiple_sigs()
     sig_file_update()

=head1 DIAGNOSTICS

 Diagnostics are either warnings(calling warning($msg)) or fatals(calling fatal($msg)).
 Warnings and fatals are exclusive; specific conditions cause warnings and specific
 other conditions cause fatals.  There is no overlap.  Warnings are conditions that may
 be of interest e.g. same header file in multiple locations or multiple -c specifications
 in a source compilation cmd, but which should not impact the full build of the project.
 Fatals are conditions that either will necessarily force the termination of the build
 e.g. a source file compile failure, or that indicate the construction of the Bld file
 has some instructions that are contradictory or missing necessary elements e.g. same
 source file matched twice in Bld file DIRS section specifications.  Warnings are written
 to the bld.warn file only.  Fatals are written identically to standard out and the
 bld.fatal file.  Warnings all start with 'WARNING:' and fatals all start with 'FATAL:'.
 There are no other types of diagnostic msgs.

=head1 INCOMPATIBILITIES

 None Known

=head1 BUGS AND LIMITATIONS

 None Known

=head1 SEE ALSO

 Do: perldoc 'bld.<project>'
     perldoc 'bld.<project>.rm'

 'make' and it's difficulties - in FEATURES AND ADVANTAGES above

=head1 GITHUB RELEASES

 https://github.com/rahogaboom/bld

     bld-1.0.4.tar.gz - entirely perldoc updates.  example projects - bld-1.0.4-git.tar.xz, bld-1.0.4-svn.tar.xz
                        and bld-1.0.4-systemd.tar.xz.

     bld-1.0.3.tar.gz - moved four more routines from bld to BldRoutines.pm.  added new project version builds for
                        git(git-2.3.0.tar.gz) and svn(subversion-1.8.11.tar.gz).  improved error reporting.  multiple
                        versions of git and svn are now built.  the naming convention for example project release
                        files has changed - bld-1.0.3-git.tar.xz, bld-1.0.3-svn.tar.xz and bld-1.0.3-systemd.tar.xz.

     bld-1.0.2.tar.gz - added capability to set Bld file EVAL section variables for interpolation into DIRS section
                        directory specifications.  improved fatal() output. updated git/svn/systemd builds to
                        Fedora21.  doc improvements.  improved exports/imports of variables/functions between
                        bld/BGC.pm/BldRoutines.pm.

     bld-1.0.1.tar.gz - added BGC.pm for global initialized constants and BldRoutines.pm for most subroutines.
                        re-built for Fedora21.  re-built bld.git.git-1.9.rc0.tar.gz and bld.svn.subversion-1.8.5.tar.gz
                        for Fedora21.  Dropped bld.systemd.systemd-208.tar.gz; will add systemd-218 or above in
                        the 1.0.2 release.  Many doc changes.

     bld-1.0.0.tar.gz - initial release
         bld.git.git-1.9.rc0.tar.gz
         bld.svn.subversion-1.8.5.tar.gz
         bld.systemd.systemd-208.tar.gz
 
=head1 AUTHOR

 Richard A Hogaboom
 richard.hogaboom@gmail.com

=head1 LICENSE and COPYRIGHT and (DISCLAIMER OF) WARRANTY

Copyright (c) 1998-2014, Richard A Hogaboom - richard.hogaboom@gmail.com
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. :-)

