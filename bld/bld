#!/usr/bin/perl

# bld - a simple flexible non-hierarchical program that uses SHA1 signatures
#       to build a single target(executable or library(static or shared)).
#       Complex multi-target projects may be built with the help of the
#       bld.<project> and bld.<project>.rm scripts and uses standard <project>
#       directory structures for the placement of code and Bld files. see
#       bld.README.  do "bld -h" for command help or "perldoc bld" for the
#       full man page

# use modern perl
use 5.018.4;

#
# standard modules
#

use warnings;
use diagnostics;
use autodie;
use English;
use Getopt::Long;
use File::Find;
use Data::Dumper;

# extract_multiple - for parsing the $BFN DIRS section
# extract_bracketed - used by extract_multiple for finding '{}''s
use Text::Balanced qw(
                         extract_multiple
                         extract_bracketed
                     );

# sha1_hex - the bld program SHA1 generator
use Digest::SHA qw(
                      sha1_hex
                  );

#
# installed modules
#

#use Modern::Perl 2014;

# this module allows the use of experimental perl language features(given, when, ~~) without generating warnings.
# to see exactly where smartmatch features are being used just comment out this line.  bld will run, but with warnings
# everyplace an experimental smartmatch feature is used.
use experimental 'switch';

use lib "./modules";
use BGC;
use BldRoutines;

# START: main bld program block
{
    my
    (
        # file related
        @eval,    # contents of the $BFN file EVAL section
        $dirs,    # contents of the $BFN file DIRS section before \s+ compression
        @dirs,    # contents of the $BFN file DIRS section after \s+ compression

        $opt_h,   # -h cmd line help option, do ./bld -h

        $comment_section, # holds comment section in Bld file for printing in $BIFN file

        # mandatory variable definitions in the EVAL section of $BFN
            $bld,        # the target to built e.g. executable, libx.a, libx.so
            $bldcmd,     # cmd used in perl system() call to build $bld object - requires '$bld' and '$O'(object files) internally
            $lib_dirs,   # space separated list of directories to search for libraries

            # mandatory option related in the EVAL section of $BFN
                $opt_s,     # to use system header files in dependency checking("system" or "nosystem")
                $opt_r,     # to inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
                $opt_lib,   # to do dependency checking on libraries("nolibcheck", "libcheck", "warnlibcheck" or "fatallibcheck")

        # booleans
        $rebuild_chgsrc, # boolean to indicate a source file has changed
        $rebuild_nosrc,  # boolean to indicate a(any) source file has been deleted
        $rebuild_target, # boolean to indicate the target has:
                         #     1. target is missing
                         #     2. signature of target does not exist in $SIGFN signature file
                         #     3. signature of target exists in signature file but is changed from actual existing target

        # primary program data structures
            %Sigdata,
                # signature data and build target library dependency data
                #
                # the hash will be two levels(for source file signature, build cmd signature and build target signature data):
                # $Sigdata{<full path or relative path file source>}[<$SIG_SRC or $SIG_CMD or $SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $SIG_SRC - source signature e.g. signature of 'source.c' or 'header.h' or 'libx.so'
                #         2. $SIG_CMD - build cmd signature e.g. signature of 'clang -c source.c -lm'
                #         3. $SIG_TGT - target signature e.g. signature of 'source.o'
                #     c. the values are signatures
                #
                # Example: # signature of source file
                #          $Sigdata{'src/C/main.c'}[$SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $Sigdata{'src/C/main.c'}[$SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $Sigdata{'src/C/main.c'}[$SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $Sigdata{'/usr/include/wchar.h'}[$SIG_SRC] = '587c23d7ebd0856b9a9a59c8b0c6469bf0c75963';
                #
                #          # signature of relative path header file
                #          $Sigdata{'src/C/head.h'}[$SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                #          # signature of build target
                #          $Sigdata{'exec-c'}[$SIG_SRC] = '7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for build target library file dependency data):
                # $Sigdata{<build target>}[<$LIB_DEP>]{<library file name>} = undef
                #     a. the first level hash has a key of the build target file name e.g. exec-c
                #     b. the second level array has an index values of $LIB_DEP - a library dependency e.g. libm.so
                #     c. the third level hash has a key of the library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $Sigdata{'exec-c'}[$LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $Sigdata{'exec-c'}[$LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                # Purpose: holds $SIGFN file signature data read in at program start for comparison to %SigdataNew program calculated data to
                #          determine what, if anything, to rebuild

            %SigdataNew,
                # signature and dependency information
                #
                # the hash will have two levels(for signature data):
                # $SigdataNew{<full path or relative path file source>}[<$SIG_SRC or $SIG_CMD or $SIG_TGT>] = '<signature>'
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of three index values:
                #         1. $SIG_SRC - source signature e.g. signature of source.c or header.h or libx.so
                #         2. $SIG_CMD - build cmd signature e.g. signature of "clang -c source.c -lm"
                #         3. $SIG_TGT - target signature e.g. signature of source.o
                #     c. the values are signatures
                #
                # Example: # library signature
                #          $SigdataNew{'/lib64/libc.so.6'}[$SIG_SRC] = '7c135fc5b3aca5ef9064bdbd51608cf1aad6feee';
                #
                #          # build target signature
                #          $SigdataNew{'exec-c'}[$SIG_SRC] = '95b0de6b76a336aed5bfb1a5fa1d757ccf1eabfc';
                #
                #          # signature of source file
                #          $SigdataNew{'src/C/main.c'}[$SIG_SRC] = 'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5';
                #
                #          # signature of source file build cmd
                #          $SigdataNew{'src/C/main.c'}[$SIG_CMD] = 'f951dd4b3366670d9fc8d71da1b74b3b5d5fade8';
                #
                #          # signature of source file target file e.g. main.o
                #          $SigdataNew{'src/C/main.c'}[$SIG_TGT] = '4a62b30b41272438b3575822223877457366c8db';
                #
                #          # signature of full path header file
                #          $SigdataNew{'/usr/include/stdc-predef.h'}[$SIG_SRC] = '51eecd0afe5466d0ea173369fbe0c91657f92d53';
                #
                #          # signature of relative path header file
                #          $SigdataNew{'src/include/head.h'}[$SIG_SRC] = 'i7354a1b2a464cb3a0f6444d4363c4aae7e40b362';
                #
                # the hash will have three levels(for header file or library file dependency data):
                # $SigdataNew{<full path or relative path file source>}[<$HDR_DEP or $LIB_DEP>]{<file name>} = undef
                #     a. the first level hash has a key of the source file full path or relative path name e.g. 'src/source.c' or '/usr/include/fcntl.h'
                #     b. the second level array has one of two index values:
                #         1. $HDR_DEP - a header dependency - the source depends on a header e.g. header.h
                #         2. $LIB_DEP - a library dependency - the $bldcmd for the $bld target depends on a library e.g. libm.so
                #     c. the third level hash has a key of the header or library file name
                #     d. the values are undef
                #
                # Example: # library dependency of build target
                #          $SigdataNew{'exec-c'}[$LIB_DEP]{'/lib64/libm.so.6'} = undef;
                #
                #          # library dependency of build target
                #          $SigdataNew{'exec-c'}[$LIB_DEP]{'/lib64/libc.so.6'} = undef;
                #
                #          # source file full path header dependency
                #          $SigdataNew{'src/C/main.c'}[$HDR_DEP]{'/usr/include/_G_config.h'} = undef;
                #
                #          # source file relative path header dependency
                #          $SigdataNew{'src/C/main.c'}[$HDR_DEP]{'src/C/l.hh'} = undef;
                #
                # Purpose: holds program calculated data - command, source, header, library and target file signature data as well as source file header dependencies and build
                #          cmd library dependencies.  data in this structure is compared with data in the %Sigdata structure to determine what, if anything, to rebuild.  just
                #          before program exit the $SIG_SRC, $SIG_CMD and $SIG_TGT signatures of %SigdataNew are written to $SIGFN and becomes the %Sigdata for the next run.

            %Objects,
                # object files
                #
                # the hash will be one level:
                # $Objects{<relative path object file>} = undef
                #     a. the keys are the object file relative path name starting from the bld home directory e.g. src/somefile.o
                #     b. the values are undef
                #
                # Example: # the tt.o object file
                #          $Objects{"\'src/C/y/tt.o\'"} = undef;
                #
                #          # the main.o object file
                #          $Objects{"\'src/C/main.o\'"} = undef;
                #
                #          Note: the inclusion of literal single quotes around the source to avoid problems with directories that have embedded spaces
                #
                # Purpose: used in the $bldcmd required variable to build the $bld target

            %SourceSig,
                # source file signatures - signatures for all source files(code or header) or libraries in the build
                #
                # the hash will be two levels:
                # $SourceSig{'<signature>'}{'<full path or relative path file source>'} = undef
                #     a. the first level hash has a key of the source signature e.g. signature of source.c or header.h or libx.so
                #     b. the second level hash has a key of the full or relative path file
                #     c. the values are undef
                #
                # Example: # w.c has same signature as w1.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w.c'} = undef;
                #
                #          # w1.c has same signature as w.c
                #          $SourceSig{'9811db426524b5cc3e453961e3294a9eb713ae60'}{'src/C/z/w1.c'} = undef;
                #
                #          # main.c has a unique signature
                #          $SourceSig{'e8bc19c1ccd64bbbe71e6a73a3a017bbaafd33e5'}{'src/C/main.c'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/C/../include/head.h'} = undef;
                #
                #          # the head.h file is in three different places
                #          $SourceSig{'7354a1b2a464cb3a0f6444d4363c4aae7e40b362'}{'src/include/head.h'} = undef;
                #
                # Purpose: if %SourceSig has, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
                #          then there is a source or library of the same signature in two different places

            %Targets,
                # target files - relative path(from the bld directory)
                #
                # the hash will be one level:
                # $Targets{'<relative path file target>'} = undef
                #     a. the first level hash has a key of the relative path(from the bld directory) build file target e.g. src/C/main.o(from main.c) or src/C/lex.c(from lex.l)
                #     b. the values are undef
                #
                # Example: # build target of m.c source
                #          $Targets{'src/C/a b/m.o'} = undef;
                #
                #          # build target of main.c source using gcc
                #          $Targets{'src/C/main.o'} = undef;
                #
                #          # build target of main.c source using as
                #          $Targets{'src/C/main.s'} = undef;
                #
                # Purpose: for each source picked up by a DIRS section regex and built by the corresponding cmd a single target file will be produced.
                #          these files in relative path form from the build directory are used as hash keys.  if two identical target file names are created
                #          (both path and file name) they would overwriting one another.  as targets are added to the build, a new hash key that
                #          already exists will fatal().  if a source is not rebuilt then it will not be added to %Targets.  only rebuilt targets are added.
    );

    # initially interrupts just fatal(); after the $BFN file has been processed and the $SIGFN has been read in, int_sig_handler()
    # will handle them and first write out any partially accumulated new signatures to $SIGFN and then fatal().
    local $SIG{INT} = sub {
                              my (
                                     $signame,
                                 ) = @_;

                                 fatal("\nInterrupted with signal $signame");
                          };

    GetOptions
    (
        "h" => \$opt_h,
    ) or fatal("FATAL: GetOptions() failed(use bld -h).");

    if ( @ARGV > 0 )
    {
        my $msg = sprintf "FATAL: Arguments specified - takes only options.";
        fatal($msg);
    }

    # help msg
    opt_help() if $opt_h;

    {
        # clear $BIFN, $BWFN and $BFFN files

        open my $bifnfh, ">", $BIFN;
        close $bifnfh;
        open my $bwfnfh, ">", $BWFN;
        close $bwfnfh;
        open my $bffnfh, ">", $BFFN;
        close $bffnfh;
    }

    # scan $BFN file accumulating EVAL lines(in @eval) and DIRS lines(in $dirs) for later processing.
    my ( @tmp ) = Bld_section_extract();
    $comment_section = shift @tmp;
    $dirs = pop @tmp;
    @eval = @tmp;

    if ( @eval == 0 )
    {
        my $msg = sprintf "FATAL: %s EVAL section is empty.", $BFN;
        fatal($msg);
    }

    {
        # if a $BGVFN file exists read in as an array and prepend to the @eval array.
        # this allows the $BGVFN file to serve as a source of global variable defines.

        my @bldrc;

        # slurp in $BGVFN file to array
        if ( -f "$BGVFN" and -r "$BGVFN" )
        {
            open my $bldrcfh, "<", "$BGVFN";
            @bldrc = <$bldrcfh>;
            close $bldrcfh;
        }

        unshift @eval, @bldrc;
    }

    {
        # eval() the EVAL section code of the $BFN file.  this must be 'no strict' or
        # interpolation will complain about undefined variables.

        no strict;
        eval "@eval";
        use strict;

        # check for syntax errors($@).  see perldoc.perl.org -> perlvar -> $EVAL_ERROR
        if ( $EVAL_ERROR )
        {
            my $msg = sprintf "FATAL: %s EVAL section: Fatal eval error: %s", $BFN, $EVAL_ERROR;
            fatal($msg);
        }

        if ( $opt_s ne "system" and $opt_s ne "nosystem" )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_s: \'%s\'", $opt_s;
            fatal($msg);
        }
        if ( $opt_r ne "rebuild" and $opt_r ne "norebuild" )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_r: \'%s\'", $opt_r;
            fatal($msg);
        }
        if (
               $opt_lib ne "nolibcheck" and
               $opt_lib ne "libcheck" and
               $opt_lib ne "warnlibcheck" and
               $opt_lib ne "fatallibcheck"
           )
        {
            my $msg = sprintf "FATAL: Invalid value for \$opt_lib: \'%s\'", $opt_lib;
            fatal($msg);
        }
    }

    if ( not defined $bld or not defined $bldcmd or not defined $lib_dirs )
    {
        my $msg = sprintf "FATAL: One or more of %s file required variable definitions \$bld, \$bldcmd and \$lib_dirs are missing.", $BFN;
        fatal($msg);
    }

    if ( not defined $opt_s or not defined $opt_r or not defined $opt_lib )
    {
        my $msg = sprintf "FATAL: One or more of %s file required variable definitions \$opt_s and \$opt_r and \$opt_lib are missing.", $BFN;
        fatal($msg);
    }

    $bld =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $bldcmd =~ s{\s+}{ }g; # compress white space to a single space
    $lib_dirs =~ s{^\s*|\s*$}{}g; # strip pre/post white space
    $lib_dirs =~ s{\s+}{ }g; # compress white space to a single space

    # if "nosystem" remove library search directories that start with '/'
    if ( $opt_s eq "nosystem" )
    {
        my @tmp = grep { /^[^\/]/ } split /\s+/, $lib_dirs;
        $lib_dirs = join $SPACE, @tmp;
    }

    # write initial info to the bld.info file
    init_blddotinfo( $bld, $bldcmd, $lib_dirs, $opt_s, $opt_r, $opt_lib, $comment_section );

    # process $BFN file DIRS section
    @dirs = dirs_pro( $dirs, $opt_s );

    # scan EVAL and DIRS sections for variables.  if variables in EVAL but not in DIRS do warning().
    # if variables in DIRS but not in EVAL, do warning() and fatal().
    variable_match( \@eval, \@dirs );

    # read $SIGFN file data into %Sigdata
    read_Blddotsig( $bld, \%Sigdata );

    # enable ^C interruption
    local $SIG{INT} = \&int_sig_handler;

    # 
    # Usage      : ^C
    #            : kill INT => $PID;
    #
    # Purpose    : interrupt handler, not called directly, but by the program receiving at INT signal.
    #            : this may happen in two ways - a. a ^C is typed at the keyboard during program execution and
    #            : b. during a call to the fatal() routine.  fatal() prints it's calling msg to the $BFFN file
    #            : and then signals an INT to the program.
    #
    # Parameters : called with the SIG name of the interrupt
    #
    # Returns    : fatal()
    #
    # Globals    : %Sigdata
    #            : %SigdataNew
    #
    # Throws     : None
    #
    # Notes      : None
    #
    # See Also   : None
    #
    sub int_sig_handler
    {
        #requires global variables:
        my (
               $signame,
           ) = @_;

        %SigdataNew = ( %SigdataNew, %Sigdata );

        sig_file_update( $bld, \%SigdataNew );

        fatal("\nInterrupted with signal $signame");
    }


    #
    # CHECK COMPILATION UNITS
    #

    # boolean to indicate that any source file was rebuilt and thus $bld will need rebuilding
    $rebuild_chgsrc = "false";

    # for each directory line in $BFN, check sources and if needed rebuild with $cmd
    # for that directory.  a source file will be rebuilt if a $SIGFN file signature entry
    # does not exist for this source file, indicating a new source file, or the source
    # file signature has changed.

    foreach my $line ( @dirs )
    {
        given ( $line )
        {
            when ( m{$RGX_CMD_BLOCK} )
            {
                my ( $cmd, $cmd_var_sub );

                # DIRS section cmd block
                $cmd = $line;

                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                # interpolate perl variables in $cmd
                $cmd_var_sub = var_sub( $cmd );

                if ( $cmd_var_sub ne $EMPTY )
                {
                    my ( $status, $error_msg );

                    # convert '!!!' strings back to newlines for execution
                    $cmd_var_sub =~ s{!!!}{\n}g;

                    # execute $cmd_var_sub's
                    $status = system "$cmd_var_sub";

                    if ( $status != 0 )
                    {
                        $error_msg = system_error_msg( $CHILD_ERROR, $ERRNO );

                        my $msg = sprintf "FATAL: Error msg: %s\nCmd: \"%s\"\nFail status: %s", $error_msg, $cmd_var_sub, $status;
                        fatal($msg);
                    }
                }

                print "{$cmd_var_sub}\n";
                next;
            }
            when ( m{$RGX_VALID_DIRS_LINE} )
            {
                my ( $dir, $regex_srcs, $cmd );

                # DIRS section three field specification line - '[R] dir:regex:{cmds}'

                # split dir lines on ":" and remove $regex_srcs enclosing '{' and '}', and $cmd enclosing '{' and '}'
                ($dir, $regex_srcs, $cmd) = split $COLON, $line;

                # add double quotes around the source file $s in order to handle spaces in the file name
                $cmd =~ s{\$s}{"\$s"}g;

                $regex_srcs =~ s{^\{|\}$}{}g; # remove $regex_srcs regex delimiters
                $cmd =~ s{^\{|\}$}{}g; # remove $cmd delimiters

                # interpolate perl variables in $dir
                $dir = var_sub( $dir );

                opendir my ( $dirfh ), $dir;

                # a. read $dir directory b. select only ordinary files that match $regex_srcs c. map files to relative path name
                my @Sources = map { "$dir/$_" } grep { $_ =~ m{$regex_srcs} and -f "$dir/$_" } readdir $dirfh;
                closedir $dirfh;

                foreach my $s ( @Sources )
                {
                    my ( $cmd_var_sub, $truefalse );

                    # find perl variables in $cmd and substitute EVAL section values for these variables
                    # and substitute the $s variable from the @Sources array.
                    # NOTE: do 'perldoc -q "How can I expand variables in text strings"' to see a discussion
                    #       of how this(s{}{}gee) works and possible alternatives.

                    $cmd_var_sub = $cmd;
                    no strict;
                    $cmd_var_sub =~ s{(\$$RGX_PERL_VARIABLE)}{$1}gee;
                    use strict;

                    $truefalse = src_pro( $s, $cmd_var_sub, $bld, $opt_s, $opt_r, \%Sigdata, \%Depend, \%SigdataNew, \%SourceSig, \%Objects, \%Targets );

                    # if any $s needs rebuilding set $rebuild_chgsrc to "true"
                    if ( $truefalse eq "true" )
                    {
                        $rebuild_chgsrc = "true";
                    }
                } # END: foreach my $s (@Sources){}
            }
            default
            {
                my $msg = sprintf "FATAL: %s DIRS section line is incorrectly formatted(see %s): %s", $BFN, $BIFN, $line;
                fatal($msg);
            }
        }
    } # END: foreach my $line ( @dirs ){}

    if ( not %Objects )
    {
        my $msg = sprintf "FATAL: No source file matched in any DIRS section line regular expression.";
        fatal($msg);
    }


    #
    # CHECK TARGET AND REBUILD IF NECESSARY
    #

    # boolean indicating to rebuild target if any of three conditions is true:
    #     1. target is missing
    #     2. signature of target does not exist in $SIGFN signature file
    #     3. signature of target exists in signature file but is changed from actual existing target
    $rebuild_target = rebuild_target_bool( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Sigdata, \%SigdataNew );

    # if a(any) source has been deleted($s exists in %Sigdata and does not exist in %SigdataNew) then force rebuild
    $rebuild_nosrc = "false";
    foreach my $s ( keys %Sigdata )
    {
        if ( not $s ~~ %SigdataNew )
        {
            $rebuild_nosrc = "true";
        }
    }

    # rebuild if:
    #     1. a source file of executable has changed($rebuild_chgsrc)
    #     2. or a source file has been deleted($rebuild_nosrc)
    #     3. or the target is has any of the three conditions listed above($rebuild_target)
    if ( $rebuild_chgsrc eq "true" or $rebuild_nosrc eq "true" or $rebuild_target eq "true" )
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that would be rebuilt, but do not rebuild
            print "---WILL--- be rebuilt: $bld\n";
        }
        else
        {
            rebuild_exec( $bld, $bldcmd, $lib_dirs, $opt_lib, \%Objects, \%SigdataNew );
        }
    }
    else
    {
        if ( $opt_r eq "norebuild" )
        {
            # print executable file name that will not be rebuilt
            print "$bld will NOT be rebuilt.\n";
        }
        else
        {
            print "$bld is up to date.\n";
        }
    }

    # DEBUG
    # if debugging, for dumping the primary program data structures
=for
    print "DEBUG:\n";
    print Data::Dumper->new([\%Depend],[qw(\%Depend)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Sigdata],[qw(\%Sigdata)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SigdataNew],[qw(\%SigdataNew)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Objects],[qw(\%Objects)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%SourceSig],[qw(\%SourceSig)])->Indent(3)->Quotekeys(0)->Dump;
    print Data::Dumper->new([\%Targets],[qw(\%Targets)])->Indent(3)->Quotekeys(0)->Dump;
    print "ENDDEBUG:\n";
=cut

    # if %SourceSig, for a given $signature(first subscript), has more than one source or library file entry(second subscript)
    # then there is a source or library of the same signature in two different places
    multiple_sigs( \%SourceSig );

    # if $opt_r option is "norebuild" do not rebuild - do not touch $SIGFN file
    if ( $opt_r eq "norebuild" ) { exit 0; }

    # ignore interrupts while $SIGFN is being written
    local $SIG{INT} = 'IGNORE';

    # writes %SigdataNew signature data to $SIGFN and header/code file inventory to $BIFN
    sig_file_update( $bld, \%SigdataNew );

    exit 0;
}
# END: main bld program block


#
# SUBROUTINES SECTION - Global data dependent(only var_sub())
#
#     Note: The global data is all of the variables imported from the EVAL section of the $BFN file by the eval "" of that section
#


# 
# Usage      : $cmd_var_sub = var_sub( $cmd );
#            :     - note: called in scalar context
#            : %dirs_vars_tmp = var_sub( $cmd, '$s' );
#            :     - note: called in list context
#            : %eval_vars = var_sub( $eval_vars, '$bld', '$bldcmd', '$lib_dirs', '$O', '$opt_s', '$opt_r', '$opt_lib' );
#            :     - note: called in list context
#
# Purpose    : depending on the calling context do:
#            :     1. scalar context - simple variable($name) substitution and return the substituted string.
#            :     2. list context - create a hash of string,
#            :        for $a = 1 - key = 'simple variable name($a -> 'a')'/value = 'simple variable value(1)',
#            :        entries and return the hash.
#            : exclude from processing the list of variable entries after the $cmd input string.
#            : the return depends on calling context(see wantarray()).
#
# Parameters : $cmd     - command string
#            :            Note: $cmd may have embedded newlines.  this is OK as m{\$($RGX_PERL_VARIABLE)}g should match newlines.
#            :
#            : @exclude - list of variables to exclude from substitution - applies to both $cmd and %h returns.
#            :            these variables may be specified either with or without the leading '$' sign. e.g. '$bld' or 'bld'
#
# Returns    :     1. if wantarray is false:
#            :            do variable substitution on $cmd, excepting variable names
#            :            passed in the @exclude array, and return it
#            :     2. if wantarray is true:
#            :            extract variable names from $cmd and build a hash with variable names
#            :            as keys and values as the values of those variables - return that hash
#
# Globals    : All of the variables imported from the EVAL section by the eval "" of that section
#
# Throws     : None
#
# Notes      : 1. the exclude list may have variables listed without the scalar variable prefix $ sign e.g. 'bld'.  however,
#            :    '$bld' seems better because it reminds the user that the exclude list is a list of variables.
#            : 2. the @exclude arguments must not be interpolated - thus they should be of the form '$string' with single quotes
#            : 3. ignore entirely any %hash variables($hash{a}) or @array variables($array[0]) -
#            :    these may be used freely in the EVAL section
#
# See Also   : perldoc -f wantarray
#
sub var_sub
{
    my (
           $cmd,
           @exclude,
       ) = @_;

    # hash with variable/variable value
    my ( %h );

    # for return type
    my ( $wantarray );


    $wantarray = wantarray();

    foreach my $exclude ( @exclude )
    {
        $exclude =~ s{^\$}{}; # strip leading '$' sign
    }

    # find all(except from @exclude) simple perl variables($name) and, depending on the calling context,
    # either substitute their values or build a hash with variable/variable value entries.  ignore
    # entirely any %hash variables($hash{a}) or @array variables($array[0])
    while ( $cmd =~ m{ \$($RGX_PERL_VARIABLE) }gx )
    {
        my $varmatch = $1;

        # if $varmatch is in @exclude skip it
        last if $varmatch ~~ @exclude;

        no strict;
        if ( $wantarray )
        {
            $h{"\$$varmatch"} = ${$varmatch};
        }
        else
        {
            $cmd =~ s{\$$varmatch}{${$varmatch}};
        }
        use strict;
    }

    return $wantarray ? %h : $cmd;
}

1;

__END__

=head1 NAME

 bld

=head1 VERSION

 bld version 1.0.3

=head1 USAGE

 usage: bld [-h]
     -h          - this message.(exit)

=head1 ARGUMENTS

 None

=head1 OPTIONS

bld [-h]

-h
        help message(exit)

=head1 ENVIRONMENT VARIABLES

 None

=head1 RC CONFIGURATION FILES

 None

=head1 DEPENDENCIES

 Required for execution:
    experimental.pm(3pm) - for smartmatch and switch features
    cpp(1) - gnu cpp cmd is required for dependency determination
    ldd(1) - used for library dependency determination

 Required for test:
    gcc(1)/g++(1) (http://gcc.gnu.org/)
    clang(1) (http://llvm.org/)

=head1 FEATURES AND ADVANTAGES

 1. Everything is done with SHA1 signatures.  No dates are used anywhere.  Signatures are a property of the
    file and not meta data from the system used for the build.  Any time issues, whether related to local
    clocks, networked host clocks or files touched by command activities are eliminated.  Modern signature
    algorithms are strongly randomized even for small file changes - for the 160 bit SHA1 hash collisions are
    unlikely in the extreme.  The Digest::SHA module is fast.  The expense of signature calculation times 
    is small relative to the expense of programmer time.  An investigation of some other make alternatives
    e.g. scons, cook - will disclose that they too are using signatures - maybe for exactly for the same reasons.
 2. bld is REALLY simple to use.  There are no arguments, no options(except -h), no environment variables and
    no rc files.  The entire bld is controlled from the Bld(and Bld.gv file) file.  Only a minimal knowledge
    of perl is needed - variable definitions and simple regular expressions.
 3. Automatic dependency checking - GNU cpp is used to find the header file dependencies.  Optionally, header
    file checking may be done for user header files only or for simultaneously both system header and user
    header files.  All header file dependency information associated with each source is saved to the
    bld.info file.
 4. There are no built in dependency rules.  The Bld file DIRS section specifications give what is to be
    built from what and the Bld file EVAL section gives how to assemble all the components for the target.
 5. bld is not hierarchical.  A single Bld file controls the construction of a single target(a target is an
    executable or library(static or shared)).  Complex multi-target projects use one Bld.gv(global values)
    file and many Bld files - one to a target.  The source directory structure goes under bld.<project>/<version>
    and each target Bld file(Bld.<project>.<target>) encapsulates all the build information for all the
    source directories under bld.<project>/<version>.  All the built targets and build information files go
    into the Bld.<project>/<version> directory.  See 13 below for reasons why recursive make causes problems.
 6. Each source file will have three signatures associated with it - one for the source file, one for the
    corresponding object file and one for the cmds use to rebuild the source.  A change in any of these will
    result in a rebuild.  A change in the target signature will result in a rebuild.  Optionally, the
    signatures of dynamic libraries may be tracked.  If a library signature changes the bld may warn or stop
    the rebuild.  If dynamic libraries are added or deleted from the bld this can ignore/warn/fatal.
 7. If any files in the bld have the same signature this is warned about e.g. two header or source files of
    the same or different names.
 8. Complex multi-target projects are built with a standard directory setup and a standard set of scripts -
    Directories:
        Bld.<project>/<version>       - has all files controlling <project> <version>s blds and bld target output files
        bld.<project>/<version>       - source code for <project> <version>s

    Files:
        bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
        bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
        bld.<project>.targets         - list of all <project> targets
        bld.<project>.README          - <project> README
        bld.<project>.install         - <project> install script
        bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
        Bld.<project>.<target>        - the Bld file for each <project> <target>
        Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
 9. Security - since the signatures of everything(source, objects, libraries, executable) are checked it is
    more difficult to insinuate an exploit into a source, object, library or executable during the build process.
 10. The capture of the full build process in the bld.info, bld.warn and bld.fatal files allows easy access to
     and saving of this information.  For multi-target projects with the target names appended to these files
     it allows quick investigation of the build process of many interrelated targets at the same time.
 11. Perl - since bld is all perl and since all warnings and fatals have the source line number associated with
     them, it is very easy to locate in the souce code the exact location of an error and examine the context
     about which the error occurred and routine that the error was produced in.
 12. Time - programmer time; learning about, maintaining/debugging Makefiles and Makefile hierarchies, dependency
     checking integration and formulation of Makefile strategies, automatic Makefile generation with Autotools -
     these all dominate the programmer time and expense of 'make'.  bld only requires basic perl variables(in
     the Bld file EVAL section) and '[R] dir:regex:{cmds}' line specifications(in the Bld file DIRS section).
 13. 'make' and it's difficulties:
         http://www.scons.org/wiki/FromMakeToScons
             a detailed critique of make and some alternatives
         http://www.scons.org/architecture/
             a description of the scons architecture and in particular the reasons for the use of signatures instead of dates
         ftp://ftp.gnu.org/old-gnu/Manuals/autoconf/html_mono/autoconf.html#SEC3
             a brief critique of make and how GNU automake from the GNU Build System contributes
         http://aegis.sourceforge.net/auug97.pdf
             an article "Recursive Make Considered Harmful" by Peter Miller from the Australian UNIX Users Group
         http://www.conifersystems.com/whitepapers/gnu-make/
             an in depth critique of make

=head1 PROJECT STATE

 Needed:
 1. The git, svn and systemd projects need work.  I ran ./configure before each bld.  I used
    no options.  How options affect the generated code and thus the Bld files is important.
    Anyone willing to investigate configure options and how these options affect the Bld files
    is welcome.

 2. The bld.<project>.install scripts all need to be done.  I'd prefer to partner with someone
    knowledgeable about the installation of git, svn and systemd.

 3. All the Bld.gv.<project> files should be vetted by a <project> knowledgeable builder.

 4. The git, svn and systemd projects will all be creating new versions eventually.  Anyone
    that would like to add bld.<project>/<version> and Bld.<project>/<version> directories
    with the new versions is welcome.

 5. I need someone with substantial experience building the linux kernel to advise me or partner
    with me on the construction of 3.19 or later.

 6. If you successfully bld a new project and wish to contribute the bld, please do so.  I'm 
    interested in how others construct/organize/document/debug projects and their Bld files.

=head1 DESCRIPTION

 bld(1.0.3) is a simple flexible non-hierarchical program that builds a single C/C++/Objective C
 /Objective C++/Assembler target(executable or library(static or shared)) and, unlike 'make', uses SHA1
 signatures(no dates) for building software and GNU cpp for automatic header file dependency
 checking.  The operation of bld depends entirely on the construction of the Bld(bld specification)
 and Bld.gv(bld global values) files.  See the bld.README file.  There are no cmd line arguments or
 options(except for -h(this msg)) or $HOME/.bldrc or ./.bldrc files and no environment variables are
 used.  Complex multi-target projects are bld't with the use of a Bld.<project> (Bld files and
 target bld output files) directory, bld.<project>(project source) directory, bld.<project>(target
 construction) script, bld.<project>.rm(target and bld.<info|warn|fatal>.<target> file removal)
 script, Bld.<project>.gv(project global values) file, bld.<project>.install(target and file
 install) script and bld.<project>.README(project specific documentation) file.  Current example
 projects:

     Bld.git - the git project http://git-scm.com/
     Bld.svn - the subversion project http://subversion.apache.org/
     Bld.systemd - the systemd project http://www.freedesktop.org/wiki/Software/systemd/
     Bld.example - misc examples intended to show how to create Bld and Bld.gv files

 bld is based upon taking the SHA1 signature of anything that, when changed, would require a
 rebuild of the executable/library.  It is not, like 'make', based in any way on dates.  This
 means that source or header files may be moved about, and if the files do not change then
 nothing needs to, or will, be rebuilt.  bld is not hierarchical; all of the information to
 rebuild the executable is contained in the Bld(and Bld.gv) file.  The rebuild is based on Perl's
 regex engine to specify source file patterns along with the Perl eval{} capability to bring
 variable definitions from the Bld file into the source.

 bld reads the Bld file which describes the build.  This example Bld file serves for the
 following discussion:

    Program description and Bld file explanatory comments go here.(and are ignored by bld)
    EVAL
    DIRS

 The Bld file has three sections , a starting comment section to document the Bld, an EVAL and DIRS.
 Variables to be used for interpolation into build commands are defined in the EVAL section.
 The variables are all Perl variables.  The entire EVAL section is eval{}'ed in bld.  Any
 errors will terminate the run.  The DIRS section has three field(: 0) lines which are
 the directory, the matched files to a Perl regular expression, and a build command for the line
 matched files.  EVAL section variable definitions are interpolated into the build commands.
 bld will execute "$cmd $dir/$s"; for each source file, with $cmd from the interpolated third
 field, $dir from the first field, and $s from the matched source second field of the DIRS
 section lines.  Rebuilds will happen only if:

    1. a source file is new or has changed
    2. the corresponding object file is missing or has changed
    3. the command that is used to compile the source has changed
    4. a dependent header file has changed
    5. the command to link the executable or build the library archive has changed
    6. the executable or library has changed or is missing

 The Bld.sig file, automatically built, holds the source/object/header/executable/library file
 names and the corresponding signatures used to determine if a source should be rebuilt the
 next time bld is run.  Normally, system header files are included in the rebuild criteria.
 However, with the -s switch, signature testing of these files can be disabled to improve
 performance.  It is unusual for system header files to change except after a new OS
 installation.

 add description of directory structure - o dir - build dir

=head1 QUICK START

 1. Bld'ing the systemd project - http://www.freedesktop.org/wiki/Software/systemd/
    a. cd Bld.systemd/systemd-208 # puts you into the systemd(systemd-208) project directory
    b. ./bld.systemd --all        # bld's all of the systemd targets and bld target output files -
                                        the bld.info.systemd.<target>,
                                        the bld.warn.systemd.<target>,
                                        the bld.fatal.systemd.<target>,
                                        files
    c. ./bld.systemd.rm --all     # cleans up everything

 2. Bld'ing the svn project - https://subversion.apache.org/
    a. cd Bld.svn/subversion-1.8.5 # puts you into the svn(subversion-1.8.5) project directory
    b. ./bld.svn --all             # bld's all of the svn targets and bld target output files -
                                         the bld.info.svn.<target>,
                                         the bld.warn.svn.<target>,
                                         the bld.fatal.svn.<target>,
                                         files
    c. ./bld.svn.rm --all          # cleans up everything

 3. Bld'ing the git project - http://www.git-scm.com/
    a. cd Bld.git/git-1.9.rc0 # puts you into the git(git-1.9.rc0) project directory
    b. ./bld.git --all        # bld's all of the git targets and bld target output files -
                                    the bld.info.git.<target>,
                                    the bld.warn.git.<target>,
                                    the bld.fatal.git.<target>,
                                    files
    c. ./bld.git.rm --all     # cleans up everything

 4. Bld'ing any single target
    a. cd bld       # the main bld directory - cd here when you unpack the bld.tar.xz file
    b. Install the source code in a sub-directory of the bld directory
    c. Create a Bld file - the Bld file entirely controls the target bld - see example below
    d. ./bld -h     # the bld usage msg
    e. ./bld        # do the bld
    f. ./bld.rm     # clean up
    g. vi Bld.sig   # examine the bld signature file
    h. vi bld.info  # detailed info about the stages of the bld
    i. vi bld.warn  # warning msgs from the bld
    j. vi bld.fatal # fatal msgs that terminated the bld - should be empty if bld is successful

=head1 FILES

 ~/bld directory files:
 bld        - the bld perl script
 bld.rm     - script to clean the bld directory
 bld.README - for first point of contact quick start
 Bld        - the bld file which controls bld and the construction of a target
 Bld.gv     - the file of global values imported into the Bld file(unusually used only for multi-target builds)
 Bld.sig    - the signature(SHA1) file created from the Bld file
 bld.info   - information about the bld 
 bld.warn   - warnings from the bld 
 bld.fatal  - the fatal msg that ended the bld 

 ~/bld directories:
 Bld.<project>/<version> - has all files controlling <project> <version>s blds and bld target output files
 bld.<project>/<version> - source code for <project> <version>s
 aux                     - template scripts for <project> blds

 ~/bld/aux files:
 aux/bld.<project>       - template copied to Bld.<project>/<version> directories to bld multi-target projects
 aux/bld.<project>.rm    - template copied to Bld.<project>/<version> directories to clean multi-target projects

 ~/bld/Bld.<project>/<version> files:
 bld.<project>                 - for initiating single target, multi-target or all target blds of a <project>
 bld.<project>.rm              - for initiating single target, multi-target or all target clean of a <project>
 bld.<project>.targets         - list of all <project> targets
 bld.<project>.README          - <project> README
 bld.<project>.install         - <project> install script
 bld.<project>.script.<script> - scripts called by the Bld.<project>.<target> files
 Bld.<project>.<target>        - the Bld file for each <project> <target>
 Bld.gv.<project>              - global values imported into all Bld.<project>.<target> files
 Bld.sig.<project>.<target>    - the signature(SHA1) file for each <project> <target>
 bld.info.<project>.<target>   - the bld.info file for each <project> <target>
 bld.warn.<project>.<target>   - the bld.warn file for each <project> <target>
 bld.fatal.<project>.<target>  - the bld.fatal file for each <project> <target>
 bld.<project>.targets         - all of the <project> targets

=head1 PRIMARY PROGRAM DATA STRUCTURES

 TBD

=head1 NOTES

 1. bld assumes that a source will build a derived file e.g. .o files in the same directory and
    have the same root name as the source.  of course, a subsequent Bld file {} block can rename 
    and move the .o files.

 2. bld assumes that all targets in multi-target bld's will be uniquely named - all targets go
    into the same project directory before distribution for installation.

 3. Some projects violate either or both of these target naming or object file naming/location
    requirements, but reconstructing these projects with bld should be relatively easy
    e.g. systemd.

 4. bld executes cmd fields({}) in the bld directory and then moves all created files to the
    source directory.

    Very old notes - needs updating:

    1. bld uses two adjunct files: Bld and Bld.sig.  The Bld file describes all the sources,
       their locations, and the rules for building them.  Since bld is not hierarchical the
       Bld file is the only place where build information is located.  The Bld file consists
       of two subsection types: EVAL and DIRS.  The file must begin with one EVAL section.
       The EVAL section is Perl code that is eval{}'ed by bld.  Variables that the user wants
       to have interpolated into source file build commands are defined here.  Three variables
       are mandatory: $exec(the executable name), $link(the executable building rule), and
       $libs(the executable libraries spec).  Other variables that are to be used in the
       expansion of source file build commands are defined here.  The EVAL keyword must start
       the line.  An eval{} error in the EVAL section will cause the termination of the
       program.  A DIRS section is specified after the EVAL section and at the end of the Bld
       file.  The DIRS keyword must start the line.  This section consists of whitespace lines,
       which are ignored, and build specification lines with three colon separated fields.  The
       fields are the directory relative to the bld executable directory, a Perl regular
       expression including /'s selecting the source files that this line is to control the
       building of, and the build command for the selected source files.  A directory may have
       several DIRS section lines selecting for different source files with different build
       commands.  Any variables in the build commands are interpolated from variables defined
       in the EVAL section.  All unnecessary whitespace in the command third field of DIRS
       section lines is compressed out.  Thus changing the spacing(spaces, tabs, and \n) of
       the command field will not affect any source rebuild.  If any source file in any of the
       directories is not selected by some regular expression, it is not included in the build.
       A simple and an extended example of Bld files is given below.
    2. The Bld.sig signature file is automatically created and updated.  It contains one line
       for each source, one line for each header file, and one line for the executable.  The
       header file lines and the executable line have two fields: the file name and its
       signature.  The source lines have three or four fields: the file name, the signatures
       of the source file, the command use to build the source, and the object file.  The
       user can modify this file to force the rebuild of files by altering the signature or
       even by deleting a line, however, any modification to a source or header file, or build
       command string will do the same thing.
    3. The user should always run bld -b after completion of a new executable Bld file.
       This option processes the Bld file and prints the expanded build command and all
       source files that each specification line selects for.  Thus, the user can see
       exactly what is going to be included in each build and how all files are going to
       be rebuilt.  Any variables defined for use in the build rules are also printed out.
    4. A bld run may be ^C interrupted.  When a normal uninterrupted run is completed the
       Bld.sig file is rewritten using only those files that were included in the build.
       Thus, if files were added or deleted this would reflect in the new Bld.sig file.  If a
       run is interrupted, all files read in from the original Bld.sig file and any new files
       already built are written out to the Bld.sig file.  This ensures that new files already
       built and old files not yet examined will not be rebuilt.  This may result in some
       entries in the Bld.sig file that no longer exist, but this will be corrected at the end
       of the next normally completed run.
    5. The -h, -r options exit without rebuilding the executable.
    6. In the Bld file anything before the EVAL is ignored.  This allows Bld file explanatory
       comments to be inserted at the start of this file.
    7. There are no imported environment variables.  The mkdir, mv, and cpp commands must
       be accessible, as well as, the commands in $cmd and $link variables.
    8. A non C or C++ source will be rebuilt if its build command has been changed or the
       source file itself has been changed.  The rebuilt output will be put back in the
       directory where the source came from under the assumption that it will be a C file
       that will then need itself to be rebuilt later on in the build sequence.

=head1 Bld FILE FORMAT

 The Bld file(and Bld.gv) controls the entire target bld.  It is divided into three sections -
 Comment(s), EVAL and DIRS:

 Add comments before the EVAL line

 EVAL

 # mandatory defined variables
     $bld="";
     $bldcmd = "";
     $lib_dirs = "";
     $opt_s = "";
     $opt_r = "";
     $opt_lib = "";

 DIRS
 # {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications

 {cmds}
 '[R] dir:regex:{cmds}'
 '[R] dir:regex:{cmds}'
 ...

 1. a comment section

 2. An EVAL(starts a line) section - this is perl code that is eval'ed in bld.  Six variables are required.  These are:
    e.g.

        EVAL
        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        Any other simple perl variables can be defined in the EVAL section and used in the DIRS section.  Environment
        variables may be set.

 3. A DIRS(starts a line) section - this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications.
    The {cmds} blocks are just a group of shell cmds, always executed.  A dir specification is a source directory relative
    to the bld directory.  The regex specification is a perl regular expression that will pick up one or more of the
    source files in dir.  The {cmds} specification describes how to build the selected source files.  Any number of
    cmds, ';' separated, may be specified within the {} brackets.

 Example Bld Files:

    Simplest(Bld.example/example/Bld.example.helloworld-c):

        The 'Hello World!' program with only the minimal required definitions.

        Comment(s)

        EVAL

        $CC = "gcc";

        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="helloworld-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "/usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "warnlibcheck";

        DIRS

        bld.example/example : ^helloworld\.c$ : { $CC -c $s; }


    Complex(Bld.example/example/Bld.example.exec-c):

        A well commented example of all of the features of a Bld file.  The code routines are all just stubs
        designed to illustrate a Bld file.

        Comment(s)

        EVAL
        # this section will define perl variables to be interpolated into DIRS section cmd fields

        # the compiler
        $CC = "clang";

        # mandatory defined variables

            # the target to built e.g. executable, libx.a, libx.so
            $bld="exec-c";

            # cmd used in perl system() call to build $bld target - requires '$bld'(target) and '$O'(object files) internally
            $bldcmd = "$CC -lm -o \$bld \$O";

            # space separated list of directories to search for libraries
            $lib_dirs = "example/lib /usr/lib /lib /usr/local/lib";

            # use system header files in dependency checking("system" or "nosystem")
            $opt_s = "system";

            # inform about any files that will require rebuilding, but do not rebuild("rebuild" or "norebuild")
            $opt_r = "rebuild";

            # do dependency checking on libraries("libcheck", "nolibcheck", "warnlibcheck" or "fatallibcheck")
            $opt_lib = "fatallibcheck";

        # some examples of variables that will be interpolated into DIRS section cmd fields
        $INCLUDE = "-I bld.example/example/include";
        $LSOPTIONS = "-l";

        # "a" or "b" to conditionally compile main.c
        $COND = "a";

        DIRS
        # this section will have either {cmds} cmd blocks or '[R] dir:regex:{cmds}' specifications

        # example of use of conditional compilation
        bld.example/example/C : ^main\.c$ : {
                                  # can have comments here too
                                  if [ "$COND" == 'a' ];
                                  then
                                      $CC -S $INCLUDE $s;
                                  fi
                                  if [ "$COND" == 'b' ];
                                  then
                                      $CC -O4 -S $INCLUDE $s;
                                  fi
                              }

        # example of execution of a bare block of cmds - '{' and '}' may be on separate lines
        {
            ls $LSOPTIONS;
        }

        # the cmd field may be put on another line(s) and indented
        bld.example/example/C : ^g\.x\.C$ :
            {
                $CC -c $INCLUDE $s;
            }

        # all three fields - dir, regex and cmd - may be put on separate lines(even with extra blank lines).
        # directories may have embedded blanks('a b').
        bld.example/example/C/a b :
        ^m\.c$      :

        {$CC -c $INCLUDE $s;}

        # example of regex field that captures multiple source files(h.c and i.c) and example of a
        # cmd field with multiple cmds - white space is irrelevant(a change should not cause a rebuild)
        # example of cmd fields with multiple cmds(ls and $CC)
        bld.example/example/C     : ^(h|i)\.c$    : {  ls -l $s;  $CC -c $INCLUDE $s;  }

        # example of assembler source
        # Note: the $CC compile produces .o output by changing the c to an o.
        #       the as output needs to be specified by the -o option.
        bld.example/example/C     : ^main\.s$ : {as -c -o main.o $s;}

        bld.example/example/C/ww  : ^u\.c$    : {$CC -c $INCLUDE $s;}

        # example of use of recursive directory search - the same regex and cmd fields
        # are applied to all subdirectories of the specified dir field(right after the 'R')
        R bld.example/example/C/y : ^.*\.c$   : {$CC -c $INCLUDE $s;}

        bld.example/example/C/x   : ^t\.c$    : {$CC -c $INCLUDE $s;}

        bld.example/example/C/z   : ^(w|w1)\.c$    : {$CC -c $INCLUDE $s;}

        # cmd blocks may execute multiple cmds(ls and pwd)
        {
            ls -lfda; pwd;
            ls;
        }

=head1 DIAGNOSTICS

 Diagnostics are either warnings(calling warning($msg)) or fatals(calling fatal($msg)).
 Warnings and fatals are exclusive; specific conditions cause warnings and specific
 other conditions cause fatals.  There is no overlap.  Warnings are conditions that may
 be of interest e.g. same header file in multiple locations, but which should not
 impact the full build of the project.  Fatals are conditions that either will
 necessarily force the termination of the build or that indicate the construction of
 the Bld file has some instructions that are contradictory or missing necessary
 elements e.g. same source file compiled twice.  Warnings are written to the bld.warn
 file only.  Fatals are written identically to standard out and the bld.fatal file.
 Warnings all start with 'WARNING:' and fatals all start with 'FATAL:'.  There are
 no other types of diagnostic msgs.

=head1 TODO/CONTEMPLATE/INVESTIGATE/EXAMINE/CHECKOUT/THINK ABOUT/HACK ON/SPO

   Software Development:

 . write new executable to compare Bld.sig signatures with Bld.<project>/<version> source for security
   purposes.  with Bld.sig protected then sofware build is protected.  write new executable to do
   Bld.sig signature compare against source for all the targets in a project build.

 . investigate `cd Bld.systemd/systemd-208; ldd ` cd before ldd

 . check: is $lib_dirs working? does this require a full path? 

 . Bld.example/example/Bld.example.rdx-c - mod rdx to delete() and search() on from one to n keys
       - do not require the full set of keys - should be easy

 . Use Find::File::Rule and File::Slurp in bld

   Test:

 . bld - allow compile of a group of 1 or more *.c files without building an exec or library
 . bld - install kernel - think about automation of 'make V=1' to Bld file
 . test execution of arbitrary perl code in Bld.<project>.gv and EVAL sections
 . do a 'make V-1 install' in the git project and see what it takes to install git
 . add new version of one of git/subversion/systemd to show how multiple versions of <project> are bld't
 . run on Mac/PC
 . test library changes
 . investigate running under the debugger and profiling
 . Unit Tests:
      . empty Bld file
      . Bld file with both, in order, EVAL and DIRS lines
      . EVAL section is correct(required variables) and DIRS section is empty
      . EVAL section is empty(required variables) and DIRS section is correct(non-empty)
      . EVAL section is empty(required variables) and DIRS section is empty

   Doc:

 . add History file
 . Doc that bld has no inherent built in rules
 . add security info
 . add explanation of aux directory
 . go thru code line by line and do code scrub, comment scrub
 . doc extensions.pl and clang-gcc-headers.pl
 . Bld file with only a {} block will execute the block but fail because of no .o files to build the target
 . add note that two project builds cannot run at the same time - Bld.sig and Bld.gv files
 . add Note about if two targets are built from the same source files - they both use the same .o files
       and may compile different .o files depending on the compile options - this results in the building
       of one target interfering with the build of the other target since the signature of the .o files
       are now different because of the other build.
 . add doc/notes about ldd and env variable LD_LIBRARY_PATH - add code to add special paths to LD_LIBRARY_PATH??
 . doc packages needed for execution of all Bld.example's :
       clang(LLVM), gcc, g++, GNUstep header of the GNUstep Base library package
 . add perldoc section on how to use bld to build a multi executable/library project e.g. subversion
 . major routine call tree
 . explain modules to install and all build/run requirements
       experimental.pm
       gcc/g++
       clang
       ldd
 . required executables are available and full paths - operation: ldd, cpp, mv, which - build: gcc, g++, clang, as
       add doc with list of all external cmds
 . FFAQ - (Fake)FAQ
 . add section on design notes - section on design philosophy
 . write subroutines summary
 . add doc about the 6 required variables and how to construct them

   Outside resources:

 . read Intermediate Perl 2nd Ed for ideas
 . investigate scons on scons.tigres.org
 . read "Managing Projects with GNU Make"
 . Links:
     . http://www.scons.org/wiki/FromMakeToScons
     . http://producingoss.com/ - Carl Fogel
     . http://coding.smashingmagazine.com/2013/01/03/starting-open-source-project/
     . http://oss-watch.ac.uk/resources/howtobuildcommunity

   Release:

 . on release ask for users to compile new projects and incorporate them into a Release bld.<project>.<version>.tar.gz file
 . slide presentation
 . article
 . LLVM community
 . GNU community
 . Contribute to Free Software Foundation
 . 37signals.com
 . Apache Software Foundation
 . send the perlbrew team a copy
 . CPAN.org
 . hunspell

   Notes:

 . to do a forced rebuild of everything delete Bld.sig or *.o
 . note on how to build both static and dynamic libraries
 . why no 'include' DIRS directive?
 . exit codes 0=success, 255=error - see bld.*
 . EVAL section %@ defines are ignored - only scalar variables - $cmd to EVAL
 . if a source is moved it will rebuild since the Bld.sig signature is keyed to the source
       file and it's path from the bld parent directory
 . same basename with different extensions will fail and same basename with same extension
       in different locations will fail because same named object will be created
 . symbolic links to source files should work - a file in one place and a link to that same
       file in another place will be detected/warned/fatal

   Consult:

 . open source release consult??

=head1 INCOMPATIBILITIES

 None Known

=head1 BUGS AND LIMITATIONS

 None Known

=head1 SEE ALSO

 bld.README

 Critique of 'make':
     http://www.scons.org/wiki/FromMakeToScons
         a detailed critique of make and some alternatives
     http://www.scons.org/architecture/
         a description of the scons architecture and in particular the reasons for the use of signatures instead of dates
     ftp://ftp.gnu.org/old-gnu/Manuals/autoconf/html_mono/autoconf.html#SEC3
         a brief critique of make and how GNU automake from the GNU Build System contributes
     http://aegis.sourceforge.net/auug97.pdf
         an article "Recursive Make Considered Harmful" by Peter Miller from the Australian UNIX Users Group
     http://www.conifersystems.com/whitepapers/gnu-make/
         an in depth critique of make

=head1 GITHUB RELEASES

 https://github.com/rahogaboom/bld
     bld-1.0.3.tar.gz - moved four more routines from bld to BldRoutines.pm.  added new project version builds
                        for git(git-2.3.0.tar.gz) and svn(subversion-1.8.11.tar.gz).  improved error reporting.
     bld-1.0.2.tar.gz - added capability to set Bld file EVAL section variables for interpolation into DIRS section
                        directory specifications.  improved fatal() output. updated git/svn/systemd builds to
                        Fedora21.  doc improvements.  improved exports/imports of variables/functions between
                        bld/BGC.pm/BldRoutines.pm.
     bld-1.0.1.tar.gz - added BGC.pm for global initialized constants and BldRoutines.pm for most subroutines.
                        rebuilt for Fedora21.  rebuilt bld.git.git-1.9.rc0.tar.gz and bld.svn.subversion-1.8.5.tar.gz
                        for Fedora21.  Dropped bld.systemd.systemd-208.tar.gz; will add systemd-218 or above in
                        the 1.0.2 release.  Many doc changes.
     bld-1.0.0.tar.gz - initial release
         bld.git.git-1.9.rc0.tar.gz
         bld.svn.subversion-1.8.5.tar.gz
         bld.systemd.systemd-208.tar.gz
 
=head1 AUTHOR

 Richard A Hogaboom
 richard.hogaboom@gmail.com

=head1 LICENSE and COPYRIGHT and (DISCLAIMER OF) WARRANTY

Copyright (c) 1998-2014, Richard A Hogaboom
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the {organization} nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. :-)

